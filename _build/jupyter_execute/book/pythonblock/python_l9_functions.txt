# представим, что на сайте дата должна выглядеть как "ГГГГ-ММ-ДД"
def check_date(date):
    # проверим, успешно ли разобъется строка по разделителю '-', их должно быть 2
    if date.count('-') != 2:
        return False

    # используем строковый метод split: разделим строку на три части. по задумке, порядок соответствующий
    # обратите внимание, split вернет list из трех элементов (до этого мы проверили, что именно столько получим)
    # какого типа будут эти элементы? str, не числа
    year, month, day = date.split('-')

    # проверим, что строка year может быть успешно превращена в целое число при помощи метода str.isdigit()
    # пусть допустимыми значениями для года будут 1901 - 2021
    # если одно из условий не выполнено, то проверка провалена
    if not (year.isdigit() and 1900 < int(year) <= 2021):
        return False

    # два других числа аналогично
    if not (month.isdigit() and 0 < int(month) < 13):
        return False

    if not (day.isdigit() and 0 < int(day) < 31):
        return False

    # если до этого проверки все пройдены, то итог - успех!
    return True

# первым делом - def
# далее - имя функции "print_theme"
# после - круглые скобки, сейчас пустые. Потом : и переход на новую строку
def print_theme():

    # тело функции из двух вызовов print(), оба с единообразным отступом
    print('Лекция про функции!')
    print('Тело кончилось')

# выше была определена print_theme, ее и вызовем
print_theme()

# определим функцию, которая принимает на вход x
def add_two(x):

    # переменная result - сумма x и 2
    result = x + 2

    # "наружу" возвращается полученное значение
    return result

# Присвоим результат выполнения функции переменной и посмотрим, что в ней
from_print_theme = print_theme()
print(from_print_theme)

# add_two при вызове ожидает получить число: сложим 2 и 2
from_add_two = add_two(2)
print(from_add_two)

# ошибочка!
print(result)

z = 'name'

def foo():
    # в foo не определена своя z, но она успешно найдется в глобальной области
    print(z)
    a = 10
    b = -5

    def bar():
        # bar успешно напечатает a, при этом значение будет найдено в
        # неймспейсе foo
        # как думаете, где находится print?
        # в built-in, то есть самой "внешней" области
        print(a)

        # создадим переменную b внутри bar
        b = 20

        # будет напечатано 20, так как поиск увенчается успехом в локальном
        # неймспейсе
        print(b)

    bar()

    # если тут раскомментировать следующую строку, будет ошибка: foo не знает
    # ничего про внутренности bar
    # print(b)

# в данном случае есть два позиционных параметра
def foo(arg1, arg2):
    print(arg1, arg2)

# в данном случае есть два позиционных параметра
def two_var_sum(var1, var2):

    # функция возвращает вычисленное значение суммы
    return abs(var1) + var2

# порядок важен!
print(two_var_sum(-1, 2), two_var_sum(2, -1))

# можно явно задавать переменные при вызове, в таком случае порядок не играет
# роли. Указывается название параметра и значение после =
print(two_var_sum(var2=2, var1=-1))

# тут позиционных аргументов нет (такое тоже может быть), поэтому сразу
# используется синтаксис со *: список, куда попадут все переданные позиционные
# аргументы, тут называется vars
def many_var_sum(*vars):

    # функция возвращает вычисленное значение суммы
    return sum(vars)

many_var_sum(1, 2, 3, 4, 5, 6)

# тут есть один позиционный параметр и один именованный
def hello(name, phrase='Привет'):

    print(f'{phrase}, {name}')

# передавать значения аргументов можно как в исходном порядке, тогда
# параметру будет присвоено соответствующее значение
hello('Саша', 'Приветствую')

# так и указывая названия параметров
hello(phrase='Здорова', name='Игорь')

# если не указать значение именованного параметра, используется дефолтное
hello('Вася')

def congrats(today, everyone=False, **names):
    """
    Функция может поздравляет людей
    Args:
        today (str): сегодняшняя дата
        everyone(bool): флаг, нужно ли поздравить всех
        names (dict): маппинг имя: дата
    """

    if everyone:
        print('Happy Birthday!')

    else:
        for name, date in names.items():
            if date == today:
                print(f'Happy Birthday, {name}')

congrats('2021-09-01', Paul='2001-03-08', Lena='1997-01-31')

lambda x: abs(x)

lambda num, div=2: 'нет' if num % div else 'да'

# сохранили в check_div функцию
check_div = lambda num, div=2: 'нет' if num % div else 'да'

# вызов совершенно обычный
print(check_div(3), check_div(5, 5))

# если без сохранения в переменную:
print((lambda x: abs(x))(-120))

import time

# на вход декоратор принимает параметр func - оборачиваемую функцию
def time_decorator(func):

    # внутри определена функция, которая "заменит" переданную
    # wrapped будет засекать, за сколько выполняется переданная функция
    def wrapped(*args):
        start = time.time()

        # почему func нет среди аргументов wrapped?
        # все аргументы, которые примет wrapped, тут передаются в func
        result = func(*args)

        end = time.time()
        print(f'Прошло {end - start} секунд')

        return result

    # возвращает декоратор тоже функцию. обратите внимание, что
    # возвращаемое значение именно объект function: после имени нет круглых
    # скобок. если бы они были, возвращался бы результат выполнения wrapped,
    # так как wrapped() - вызов функции
    return wrapped

# сохраним обернутую функцию (помним, декоратор возвращает функцию) в
# переменную, обратите внимание, что на вход декоратору передается также
# объект самой функции, а не результат ее работы
many_var_sum = time_decorator(many_var_sum)

# поведение функции поменялось, а код - нет
summed = many_var_sum(10, 0, -120, 333)

# теперь, при вызове, stupid_power сразу будет обернута!
@time_decorator
def stupid_power(x, power=5):
    result = 1
    for p in range(power):
        result *= x
    return result

powered = stupid_power(10)
