#!/usr/bin/env python
# coding: utf-8

# (deutschs_algorithm)=
# 
# # Задача Дойча
# 
# **Задача Дойча** (в английском варианте - **Deutsch's algorithm**) - это один из первых алгоритмов, показавших, что квантовый компьютер может решать задачи особым способом, отличающимся как от алгоритмов классического компьютера, так и от интуиции и здравого смысла человека. При этом такое решение может занимать меньшее количество шагов. 
# 
# Нужно прежде всего сказать, что задача Дойча не имеет практического применения, зато она является простейшим примером, с помощью которого можно понять, в чем состоит отличие квантовых алгоритмов от классических. Данный алгоритм был предложен в 1985 году, когда квантовых компьютеров еще не было, а практически он был реализован в 1998 году на 2-кубитном квантовом компьютере, работавшем на принципах ядерно-магнитного резонанса.
# 
# Итак, в чем состоит задача, которую решает алгоритм? Представьте, что у вас есть функция, которая представляет собой "черный ящик", принимающий на вход число из множества $\{0, 1\}$. Функция неким образом обрабатывает входное значение и возвращает число из этого же множества, то есть либо $0$, либо $1$. Нам известно, что эта функция принадлежит либо к классу сбалансированных функций, либо к классу константных функций (которые мы также можем называть несбалансированными). Задача алгоритма - установить, к какому классу принадлежит функция.
# 
# Рассмотрим все варианты этих двух классов функций. Всего их четыре, то есть по две функции в каждом классе. Начнем с несбалансированных:
# <br/>
# <br/>
# <b>1). $f_1(x) = 0$</b>
# <br/>
# Это функция, всегда возвращающая $0$, независимо от входного значения. 
# <br/>
# Для нее справедливы выражения: 
# <br/>
# $f_1(0) = 0$
# <br/>
# $f_1(1) = 0$
# <br/>
# 
# <b>2). $f_2(x) = 1$ </b>
# <br/>
# Такая функция всегда возвращает $1$, то есть верно следующее: 
# <br/>
# $f_2(0) = 1$
# <br/>
# $f_2(1) = 1$
# <br/>
# 
# Ну а теперь посмотрим на сбалансированные функции. 
# <br/>
# Для них характерно то, что они могут возвращать как $0$, так и $1$. В этом и заключается "баланс".
# <br/>
# <br/>
# <b>3). $f_3(x) = x$</b>
# <br/>
# Это тождественная функция, которая ничего не делает с входным значением.
# <br/> 
# Для нее справедливо следующее:
# <br/>
# $f_3(0) = 0$
# <br/>
# $f_3(1) = 1$
# <br/>
# 
# <b>4). $f_4(x) = NOT \; x$</b>
# <br/>
# А вот эта функция инвертирует входное значение, то есть возвращает не то число, 
# <br/>
# которое было подано на вход, а другое:
# <br/>
# $f_4(0) = 1$
# <br/>
# $f_4(1) = 0$
# <br/>
# 
# Классический компьютер справляется с задачей за два шага. Например, нам дана некоторая функция-"черный ящик", и мы должны установить, сбалансирована ли она.
# На первом шаге мы отправляем в функцию входное значение $0$. Допустим, мы получили на выходе также $0$. Мы можем сказать, что данная функция - либо $f_1$
# (константная функция, всегда возвращающая $0$), либо $f_3$ (сбалансированная функция, не меняющая входное значение). Для окончательного решения мы должны сделать еще один шаг - отправить в функцию значение $1$. Если при этом мы получим опять $0$, то это функция $f_1$, а если получили на выходе $1$, то искомая функция - $f_3$.
# 
# Способа, с помощью которого на классическом компьютере можно за одно действие установить, сбалансирована функция или нет, не существует. И здесь свое преимущество показывает квантовый компьютер: он может установить класс функции за одно действие.
# 
# Для начала рассмотрим простейшую схему, с помощью которой можно отправлять число на вход и получать ответ от черного ящика:
# ```{figure} /_static/qcblock/deutschs_algorithm/scheme_1.png
# :name: scheme_1
# :width: 400px
# 
# Схема 1.
# ```
# Неизвестная функция обозначена как $U_f$. Обратите внимание, что в этой схеме используются два кубита. Это нужно для того, чтобы информация, с которой работает квантовый компьютер, не стиралась. В квантовом компьютере важно, чтобы все действия с кубитами (кроме операции измерения) были обратимыми, а для этого информация должна сохраняться. В верхнем кубите будет записано входное значение, а в нижнем - выходное значение функции. Таким образом, входное значение не будет перезаписано значением, которое вернет функция.
# 
# Но нам важно будет не только сохранить значение $|x\rangle$, но также и не разрушить $|y\rangle$. Так как кубит y очевидно имеет некоторое изначальное значение, мы не можем его просто перезаписать тем числом, которое выдаст функция $f(x)$. Здесь на помощь приходит операция исключающее ИЛИ - $XOR$ (также ее можно называть сложением по модулю 2), обозначенная на схеме как $\oplus$. В процессе работы черный ящик $U_f$ не только находит значение $f(x)$, но и применяет исключающее ИЛИ к значениям $y$ и $f(x)$. 
# <br/>
# Операции $XOR$ соответствует такая таблица истинности:
# 
# | a | b | a XOR b |
# |:-:|:-:|:-------:|
# | 0 | 0 |    0    |
# | 0 | 1 |    1    |
# | 1 | 0 |    1    |
# | 1 | 1 |    0    |
# 
# Операция $XOR$ хороша для нас тем, что она не разрушает значение $|y\rangle$, так как является обратимой. Убедиться в этом можно, проверив тождество:
# <br/>
# $(a \oplus b) \oplus b = a$
# 
# *Схема 1* пока что не дает преимущества по сравнению с классическим компьютером, но мы можем ее немного усовершенствовать:
# ```{figure} /_static/qcblock/deutschs_algorithm/scheme_2.png
# :name: scheme_2
# :width: 500px
# 
# Схема 2.
# ```
# В новой схеме оба кубита вначале будут находиться в состоянии $|0\rangle$. Затем мы применим к верхнему кубиту оператор Адамара, а к нижнему - гейт $X$, а затем так же, как и к верхнему, оператор Адамара. Тем самым мы приведем оба кубита в состояние суперпозиции перед тем, как они попадут на вход функции $U_f$.
# Верхний кубит будет находиться в такой суперпозиции:
# <br/>
# $|x\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle,$
# <br/>
# а нижний - в такой:
# <br/>
# $|y\rangle = \frac{1}{\sqrt{2}}|0\rangle - \frac{1}{\sqrt{2}}|1\rangle.$
# 
# После того, как $U_f$ отрабатывает, нижний кубит, как это ни странно, уже нас не интересует, так что к нему операции больше не применяется, и его измерение также не производится.
# 
# Дело в том, что ответ на вопрос о том, сбалансирована функция $f(x)$ или нет, будет нами получен из верхнего кубита после того, как на него подействует оператор Адамара и будет произведено измерение.
# 
# В том случае, если функция сбалансирована, результат измерения верхнего кубита будет равен $1$, а если несбалансирована - $0$. 
# 
# Разберемся подробнее, почему это происходит.
