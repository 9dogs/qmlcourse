import numpy as np

a = np.array([1, 2, 3]) # создадим вектор
print(f"{a = }")

b = np.zeros((2, 2))
print(f"{b = }")

c = np.eye(3)
print(f"{c = }")

q = np.random.random((1, 100))
print(f"{q = }")

a = np.array([1, 2, 3])
b = np.array([-1, 3, 4])

diff = a - b
print(f"{diff = }")

mult = a * b
print(f"{mult = }")

scalar_mult = a @ b
print(f"{scalar_mult = }")

a = np.arange(16).reshape(4, 4)
print(f"{a = }")

# просто по индексам
print(f"a_{0,1}: {a[0, 1] = }, {a[0][1] = }")

# по слайсам
print("a_{1,1..3}", a[0, 1:3])
print(f"a_{2}: {a[2] = }, {a[2, :] = }, {a[2, ...] = }")

# по маске
mask = (a % 3 == 0)
print(f"{mask = }")
print(f"{a[mask] = }")

first_rows = np.array([True, True, False, False])
print(f"{a[first_rows] = }")

print(f"{a = }")

# None добавляет ось размерности 1
print(f"{a[None].shape = "})
print(f"{a[:, :, None].shape = }")

# : превращается в slice (None), берет все элементы вдоль размерности
print(f"{a[2, :] = "})
print(f"a[2, 0:None] = }")

# ... ellipsis, превращается в необходимое число двоеточий :,:,:
print(f"{a[...] = }")

# также ... удобен когда мы не знаем настоящий шейп массива или нужно не трогать несколько подряд идущих размерностей
z = np.arange(27).reshape(3, 3, 3)
print(f"{z[0, ..., 1] = }, {z[0, :, 1] = }")

a = np.array([1, 2, 3])
element = a[2]
print(f"{element = }")

a[2] = 5
print(f"{a = }")

# создадим вектор
a = np.array([2, 4, 6, 8])

selection = np.where(a < 5)
print(f"{selection = }")

# дополнительно мы можем передать два значения или вектора, при выполнении условия выбираются элементы из первого значения/вектора, при невыполнении - из второго
a2 = np.where(a < 5, 2, a * 2)
print(f"{a2 = }")

# np.where работает и с многомерными массивами
b = np.array([[8, 8, 2, 6], [0, 5, 3, 4]])
b_mult = np.where(b < 4, b, 1)
print(f"{b_mult = }")

a = np.array([1, 2, 3])
k = 2
broad = a * k
print(f"{broad = }")

a = np.array([1, 2, 3])
k = 2
broad = a - k
print(f"{broad = }")

f16 = np.float16("0.1")
f32 = np.float32(f16)
f64 = np.float64(f32)
print(f"{f16 = }, {f32 = }, {f64 = }")
print(f"{f16 == f32 == f64 = }")

f16 = np.float16("0.1")
f32 = np.float32("0.1")
f64 = np.float64("0.1")
print(f"{f16 = }, {f32 = }, {f64 = }")
print(f16 == f32 == f64)

print(f"{np.allclose([1e10,1e-7], [1.00001e10,1e-8]) = }")
print(f"{np.allclose([1e10,1e-8], [1.00001e10,1e-9]) = }")

a = np.array([[7, 4], [9, 8]])
b = np.array([5, 3])
solution = np.linalg.solve(a, b)
print(f"{solution = }")

a = np.array([[1., 2.], [3., 4.]])
inv = np.linalg.inv(a)
print(f"{inv = }")

print(np.linalg.eig(np.diag((1, 2, 3))))
