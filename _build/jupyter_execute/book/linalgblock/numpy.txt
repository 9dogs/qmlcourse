import numpy as np
a = np.array([1, 2, 3]) # создадим вектор
print(a.shape)
b = np.zeros((2, 2)) # создадим матричку 2х2 из нулей
c = np.eye(3) # создадим единичную матрицу 3х3
q = np.random.random((1, 100)) # случайную вектор-строку

a = np.array([1, 2, 3])
b = np.array([-1, 3, 4])
print(a - b) # разность двух векторов
print(a * b) # поэлементное произведение
print(a@b)  # скалярное произведение


a = np.arange(16).reshape(4, 4)
# у нас есть массив 4х4 с числами 1..16

# просто по индексам
print("a_{0,1}", a[0, 1], a[0][1])

# по слайсам
print("a_{1,1..3}", a[0, 1:3])
print("a_{2}", a[2], a[2, :], a[2, ...])

# по маске
mask = (a % 3 == 0) # mask.shape == (4, 4)
print(a[mask])

first_rows = np.array([True, True, False, False])
print(a[first_rows])

# None добавляет ось размерности 1
print(a.shape)
print(a[None].shape)
print(a[:, :, None].shape)

# : превращается в слайс slice(None), берет все элементы вдоль размерности
print(a[2, :])
print(a[2, 0:None])


# ... ellipsis, превращается в необходимое число двоеточий :,:,:

print(a[...], a) # одно и то же

z = np.arange(27).reshape(3, 3, 3)
print(z[0, ..., 1], z[0, :, 1]) # ... удобен когда мы не знаем настоящий шейп массива или нужно не трогать несколько подряд идущих размерностей

# создадим вектор
a = np.array([2, 4, 6, 8])
print(np.where(a < 5))

# дополнительно мы можем передать два значения или вектора, при выполнении условия выбираются элементы из первого значения/вектора, при невыполнении - из второго
print(np.where(a < 5, 2, a * 2))

# np.where работает и с многомерными массивами
a = np.array([[8, 8, 2, 6], [0, 5, 3, 4]])
print(np.where(a < 4, a, 1))

a = np.array([1, 2, 3])
k = 2
print(a * k)

a = np.array([1, 2, 3])
k = 2
print(a - k)

f16 = np.float16("0.1")
f32 = np.float32(f16)
f64 = np.float64(f32)
print(f16 == f32 == f64) # returns True
print(f16, f32, f64) # shows (0.1, 0.099975586, 0.0999755859375)


f16 = np.float16("0.1")
f32 = np.float32("0.1")
f64 = np.float64("0.1")
print(f16, f32, f64) # look similar
print(f16 == f32 == f64) # returns false


print(np.allclose([1e10,1e-7], [1.00001e10,1e-8])) # returns False
print(np.allclose([1e10,1e-8], [1.00001e10,1e-9])) # returns True

a = np.array([[7, 4], [9, 8]])
b = np.array([5, 3])
print(np.linalg.solve(a, b)) # array([ 1.4, -1.2])

a = np.array([[1., 2.], [3., 4.]])
print(numpy.linalg.inv(a)) # array([[-2. ,  1. ], [ 1.5, -0.5]])

print(np.linalg.eig(np.diag((1, 2, 3))))
