#!/usr/bin/env python
# coding: utf-8

# (numpy)=
# # Numpy
# 
# Широко используемая библиотека для вычислений с многомерными массивами. API большей частью вдохновлен MATLABом (великая и ужасная среда, язык и IDE для матричных вычислений), а теперь сам является примером для подражания API различных вычислительных пакетов.
# 
# Более последовательный гайд стоит посмотреть на [оффсайте библиотеки](https://numpy.org/devdocs/user)
# 
# 
# ## Массивы

# In[1]:


import numpy as np
a = np.array([1, 2, 3]) # создадим вектор
print(a.shape)
b = np.zeros((2, 2)) # создадим матричку 2х2 из нулей
c = np.eye(3) # создадим единичную матрицу 3х3
q = np.random.random((1, 100)) # случайную вектор-строку


# ## Math ops
# Для удобства использования np.ndarray определены арифметические операторы, так чтобы соответствовать ожиданиям:

# In[2]:


a = np.array([1, 2, 3])
b = np.array([-1, 3, 4])
print(a - b) # разность двух векторов
print(a * b) # поэлементное произведение
print(a@b)  # скалярное произведение


# ## Indexing, slicing and sugar
# 
# Numpy поддерживает кажется все разумные варианты индексации:

# In[3]:


a = np.arange(16).reshape(4, 4)
# у нас есть массив 4х4 с числами 1..16

# просто по индексам
print("a_{0,1}", a[0, 1], a[0][1])

# по слайсам
print("a_{1,1..3}", a[0, 1:3])
print("a_{2}", a[2], a[2, :], a[2, ...])

# по маске
mask = (a % 3 == 0) # mask.shape == (4, 4)
print(a[mask])

first_rows = np.array([True, True, False, False])
print(a[first_rows])


# Для работы с размерностями часто используются еще три конструкции: `None`, `...` (ellipsis, многоточие) и `:` (двоеточие).

# In[4]:


# None добавляет ось размерности 1
print(a.shape)
print(a[None].shape)
print(a[:, :, None].shape)

# : превращается в slice (None), берет все элементы вдоль размерности
print(a[2, :])
print(a[2, 0:None])


# ... ellipsis, превращается в необходимое число двоеточий :,:,:

print(a[...], a) # одно и то же

z = np.arange(27).reshape(3, 3, 3)
print(z[0, ..., 1], z[0, :, 1]) # ... удобен когда мы не знаем настоящий шейп массива или нужно не трогать несколько подряд идущих размерностей


# В целом, в numpy очень здорово реализованы методы `__getitem__`/`__setitem__`. [нужна ли эта фраза?]
# 
# Кроме того, мы можем делать индексацию по заданному условию с помощью `np.where`

# In[5]:


# создадим вектор
a = np.array([2, 4, 6, 8])
print(np.where(a < 5))

# дополнительно мы можем передать два значения или вектора, при выполнении условия выбираются элементы из первого значения/вектора, при невыполнении - из второго
print(np.where(a < 5, 2, a * 2))

# np.where работает и с многомерными массивами
a = np.array([[8, 8, 2, 6], [0, 5, 3, 4]])
print(np.where(a < 4, a, 1))


# ## Broadcasting
# 
# Что происходит, если мы хотим арифметику с массивами разных размеров?

# In[6]:


a = np.array([1, 2, 3])
k = 2
print(a * k)


# С точки зрения математики, ничего интересного тут не происходит: мы подразумевали умножение всего вектора на скаляр.
# Однако матричные операции в numpy справляются и с менее очевидными случаями, например при сложении вектора и скаляра:

# In[7]:


a = np.array([1, 2, 3])
k = 2
print(a - k)


# В numpy приняты следующие правила работы с массивами разного размера:
# 
# 1. Размерности сравниваются справа налево
# 2. Два массива совместимы в размерности, если она одинаковая, либо у одного из массивов единичная.
# 3. Вдоль отсутствующих размерностей происходит расширение повторением (repeat).
# 
# TODO: нарисовать картинку!
# [Уточните, пожалуйста, правильную ли я картинку нашёл]
# ![.](https://i.stack.imgur.com/JcKv1.png)
# 
# https://mathematica.stackexchange.com/questions/99171/how-to-implement-the-general-array-broadcasting-method-from-numpy
# 
# Be aware, автоматический броадкастинг легко приводит к ошибкам, так что лучше делать его самостоятельно в явной форме.
# 
# 
# ## floating point things
# 
# Отдельно стоит поговорить про числа с плавающей точкой.
# Число с плавающей запятой (или число с плавающей точкой) — экспоненциальная форма представления вещественных (действительных) чисел, в которой число хранится в виде мантиссы и порядка (показателя степени). При этом число с плавающей запятой имеет фиксированную относительную точность и изменяющуюся абсолютную.
# В результате, одно и то же значение может выглядеть по-разному, если хранить его с разной точностью.

# In[8]:


f16 = np.float16("0.1")
f32 = np.float32(f16)
f64 = np.float64(f32)
print(f16 == f32 == f64) # returns True
print(f16, f32, f64) # shows (0.1, 0.099975586, 0.0999755859375)


f16 = np.float16("0.1")
f32 = np.float32("0.1")
f64 = np.float64("0.1")
print(f16, f32, f64) # look similar
print(f16 == f32 == f64) # returns false


# Из-за этого для сравнения массивов с типом float используют `np.allclose`.

# In[9]:


print(np.allclose([1e10,1e-7], [1.00001e10,1e-8])) # returns False
print(np.allclose([1e10,1e-8], [1.00001e10,1e-9])) # returns True


# ## numpy & linalg fun
# 
# [Не знаю, что имеется ввиду под "Матричные трюки"]
# 
# ["вычисление попарных расстояний" - вроде обычно используется scipy/sklearn?]
# 
# 
# ### Решение системы линейных уравнений
# 
# Numpy позволяет решить систему линейных уравнений.

# In[10]:


a = np.array([[7, 4], [9, 8]])
b = np.array([5, 3])
print(np.linalg.solve(a, b)) # array([ 1.4, -1.2])


# ### Обращение матриц.
# 
# Numpy даёт возможность выполнить операцию обращения матриц.

# In[11]:


a = np.array([[1., 2.], [3., 4.]])
print(np.linalg.inv(a)) # array([[-2. ,  1. ], [ 1.5, -0.5]])


# ### Собственные вектора и числа
# 
# Вычисление собственных векторов и чисел.

# In[12]:


print(np.linalg.eig(np.diag((1, 2, 3))))


# ## Что мы узнали
# 
# - основы работы с numpy
# - индексацию в массивах
# - broadcasting
# - floating point things
# - numpy fun
