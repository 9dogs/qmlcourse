#!/usr/bin/env python
# coding: utf-8

# (ising)=
# 
# # Модель Изинга
# 
# В этой лекции мы познакомимся с моделью Изинга, которая изначально была разработана для описания магнетизма, но оказалась настолько удачной и универсальной, что сегодня к решению именно этой задачи стараются свести многие проблемы реального мира, причем не только из физики. В следующем блоке мы подробно покажем, как к гамильтонианам типа Изинга, или по другому "спиновым стеклам" могут быть сведены задачи комбинаторной оптимизации и квантовой химии. Так что знакомство с этой удивительной моделью, а также описывающим ее гамильтонианом нам просто необходимо!
# 
# ```{note}
# Специальные квантовые компьютеры компании D-Wave сконструированы так, что они могут решать вообще только одну задачу -- нахождения основного состояния гамильтонианов типа Изинга. Но эта задача настолько распространена и важна, что эти компьютеры стали первыми в мире коммерческими квантовыми компьютерами! Кстати, далее этим компьютерам у нас будет посвящена отдельная лекция.
# ```
# 
# Далее мы посвятим довольно много времени объяснению этой модели. Это может показаться скучным и занудным, но это важно для понимания того, как это все работает и как решать с помощью риационных квантовых алгоритмов реальные задачи!
# 
# ## Задача Изинга в одномерном случае
# 
# ```{note}
# Ниже мы попробуем на пальцах объяснить модель Изинга. Пробовать мы будем через цепочку атомов ферромагнетика во внешнем магнитном поле. Ели вы плохо помните физику и вам это объяснение покажется сложным, то не расстраивайтесь -- дальше мы также объясним задачу Изинга как задачу о поиске максимального разреза в графе -- известную задачу комбинаторной оптимизации.
# ```
# 
# Пусть у нас есть, например, цепочка атомов, которые обладают магнитным моментом. Например, цепочка атомов ферромагнетика, такого как железо. И мы прикладываем к этой цепочке внешнее магнитное поле.
# 
# Тогда, если поле маленькое, то наши атомы будут стараться выстроиться в антиферромагнитный порядок, когда соседние из них имеют моменты, направленные в разные стороны. Но если поле уже большое, то оно будет стремиться "повернуть" моменты по своему направлению. А если еще вспомнить, что магнитный момент атома является квантовой величиной и может быть в суперпозиции состояний в одну сторону и в противоположную, то не очень маленькое, но и не слишком большое поле будет переводить часть атомов именно в такие суперпозиции.
# 
# ```{figure} /_static/problemsblock/ising/af_ordering.png
# :width: 450px
# 
# Иллюстрация антиферромагнитного порядка
# ```
# 
# Давайте теперь запишем Гамильтониан такой системы. Для представления магнитных моментов мы будем использовать оператор $\sigma^z$ -- другими словами, спин в направлении оси $Z$. Если кто-то забыл, как выглядит оператор $\sigma^z$, то рекомендуем еще раз просмотреть [раздел про операторы Паули первой лекции](../qcblock/qubit.html#id24). Далее мы будем очень активно использовать эти матрицы для представления задач реального мира!
# 
# Для начала, в случае если внешнего поля нет, то мы должны записать взаимодействие соседних атомов. Так как у нас ферромагнетик, то минимальная энергия достигается в случае, если у нас спины противонаправленны. Это просто оператор $\sigma^z_j\sigma^z_{j+1}$, который действует на все пары соседних спинов. Ну и сразу введем некоторую константу обменного взаимодействия $J$, чтобы потом нам было удобно сравнивать ее с внешним полем. В итоге, для цепочки из $N$ спинов, получаем:
# 
# $$
# \hat{H}_{h=0} = J \sum_{i=0}^{N-1} \sigma^{z}_i\sigma^{z}_{i+1}
# $$
# 
# А теперь давайте добавим внешнее поле $h$. В этом случае, поле просто действует на все спины и пытается выстроить их, в зависимости от своего направления, например вниз. Тогда полный гамильтониан такой системы можно записать в виде:
# 
# $$
# \hat{H}_{h\neq 0} = J \sum_{i=0}^{N-1} \sigma^{z}_i\sigma^{z}_{i+1} - h\sum_{i=0}^N \sigma^{z}_i
# $$
# 
# ## Задача Изинга как задача о максимальном разрезе в графе
# 
# Задача о максимальном разрезе в графе -- это очень известная задача комбинаторики. Она относится к классу $NP$-трудных и к ней можно свести все другие $NP$ задачи. При этом ее формулировка одна из самых простых среди всего класса задач. Формулируется она следующим образом.
# 
# Нам дан граф -- набор вершин $V$ и связывающих их ребер $E$. Нам надо найти такое разделение ребер $V$ на два непересекающихся набора $V_1, V_2$, что число ребер между вершинами из разных наборов будет максимально.
# 
# ```{figure} /_static/problemsblock/ising/Max-cut.png
# :width: 400px
# :name: MaxCut
# 
# Иллюстрация задачи о максимальном разрезе в графе
# ```
# 
# Теперь давайте представим, что наши вершины графа мы моделируем спинами (или кубитами): спин "вверх" это, например, $V_1$, а спин "вниз" это $V_2$. Ну и для простоты предположим, что наш граф это просто цепочка, то есть ребра есть лишь между соседними в одномерном пространстве вершинами. Тогда легко записать функцию стоимости:
# 
# $$
# H = \sum_{i=0}^{N-1} \sigma^{z}_i\sigma^{z}_{i+1}
# $$
# 
# Ну и теперь давайте сформулируем нашу задачу чуточку сложнее -- нам надо найти не просто максимальный разрез, а такой разрез, который самый большой при наименьшем числе вершин в наборе $V_1$. Ну и, поскольку теперь у нас два вклада в стоимость, то нам нужны коэффициенты, которые покажут, что нам важнее. Пусть это будут $J$ и $h$. Финальная стоимость:
# 
# $$
# H = J \sum_{i=0}^{N-1} \sigma^{z}_i\sigma^z_{i+1} - h\sum_{i=0}^N \sigma^{z}_i
# $$
# 
# А так как у нас собственные значения $\sigma^z$ это как раз $\pm 1$, то мы совершенно справедливо можем записать это все в виде гамильтониана:
# 
# $$
# \hat{H} = J \sum_{i=0}^{N-1} \sigma^{z}_i\sigma^{z}_{i+1} - h\sum_{i=0}^N \sigma^{z}_i
# $$
# 
# Как видно, это тот же самый гамильтониан, который мы получили и для моделирования ферромагнетиков.
# 
# ```{note}
# Одномерная цепочка атомов, ну или поиск максимального разреза в графе-цепочке является простым случаем и не является NP-задачей. Однако уже в двумерном случае эта задача становится сильно сложнее, как и, например, если в цепочке атомов ферромагнетика мы добавим взаимодействие не только соседних спинов, но и взаимодействие с соседями соседа. Аналогично, модель вида Изинга сильно усложняется при добавлении вндиагональных (off diagonal elements) элементов гамильтонинана, например, когда внешнее поле направлено в другом направлении и второй член гамильтониана принимает вид, например, $h\sum_{i=N} \sigma^{x}_i$. В рамках данной лекции мы не будем очень глубоко погружаться в исследование сложности и решений моделей Изинга, однако любопытный читатель может ознакомиться с [продвинутой лекцией по этой теме](пусто).
# ```
# 
# ### Модель Изинга на чистом NumPy
# 
# Давайте попробуем реализовать гамильтониан Изинга на чистом `NumPy`/`SciPy` в виде разреженной матрицы. Для этого вспомним [из первых лекций](qubit), что действуя оператором $\sigma^z$ на $i$-й кубит, мы одновременно действуем единичным оператором на все остальные, а потом перемножаем все операторы произведением Кронекера. Из [лекций по линейной алгебре](пусто) мы помним также об ассоциативности произведения Кронекера, чем и воспользуемся:

# In[1]:


import numpy as np
from scipy import sparse
from scipy.sparse import linalg as sl

def sigmaz_k(k: int, n: int) -> sparse.csr_matrix:
    left_part = sparse.eye(2 ** k)
    right_part = sparse.eye(2 ** (n - 1 - k))

    return sparse.kron(
        sparse.kron(
            left_part,
            sparse.csr_matrix(np.array([[1, 0,], [0, -1,],]))
        ),
        right_part
    )


# Ну а теперь мы можем реализовать и сам оператор Изинга:

# In[2]:


def ising(j: float, h: float, n: int) -> sparse.csr_matrix:
    res = sparse.csr_matrix((2 ** n, 2 ** n), dtype=np.complex)

    for i in range(n - 1):
        res += j * sigmaz_k(i, n) * sigmaz_k(i + 1, n)
        res -= h * sigmaz_k(i, n)

    res -= h * sigmaz_k(n - 1, n)

    return res


# Если внешнего поля нет, то наши спины выстраиваются в полный антиферромагнитный порядок, в чем легко убедиться. Создадим оператор для такой модели и, например, 10 спинов (или 10 вершин в графе, если мы говорим в терминах Max-Cut):

# In[3]:


op = ising(1, 0, 10)
solution = sl.eigs(op, which="SR", k=1, return_eigenvectors=True)
print(f"Energy: {solution[0][0]}")


# Эта энергия соответствует антиферромагнитному порядку, в этом легко убедиться, нарисовав спины и формулу на бумажке. Внимательный читатель заметил, что в этот раз мы вернули также и первый собственный вектор, который в нашем случае является волновой функцией основного состояния. А как мы помним, квадраты элементов вектора волновой функции дают нам вероятности соответствующих битовых строк (если для вас это все звучит дико, то очень рекомендуем вернуться к [лекции про кубит](qubit)). Давайте посмотрим на эту битовую строку, или, другими словами, на порядок наших спинов в решении (или на разбиение вершин графа на два подмножества в терминах Max-Cut):

# In[4]:


def probs2bit_str(probs: np.array) -> str:
    size = int(np.log2(probs.shape[0]))
    bit_s_num = np.where(probs == probs.max())[0][0]
    s = f"{bit_s_num:b}"
    s = "0" * (size - len(s)) + s

    return s

probs = solution[1] * solution[1].conj()
print(probs2bit_str(probs))


# Теперь давайте попробуем добавить внешнее поле с коэффициентом, равным удвоенному значению константы обменного взаимодействия. В терминах комбинаторной задачи, мы добавляем штраф, равный два умножить на число спинов, направленных вверх.

# In[5]:


op = ising(1, 2, 10)
solution = sl.eigs(op, which="SR", k=1, return_eigenvectors=True)
print(f"Energy: {solution[0][0]}")

probs = solution[1] * solution[1].conj()
print(probs2bit_str(probs))


# Видим, что теперь наш антиферромагнитный порядок уже не полный. В целом, данная модель довольно интересная, так как при некотором отношении $\frac{h}{J}$ у нас происходит фазовый переход от полной упорядоченности, а при дальнейшем росте $h$ мы приходим к полностью одинаковой ориентации всех спинов, в чем легко убедиться, взяв, например, $h = 100$:

# In[6]:


op = ising(1, 100, 10)
solution = sl.eigs(op, which="SR", k=1, return_eigenvectors=True)
print(f"Energy: {solution[0][0]}")

probs = solution[1] * solution[1].conj()
print(probs2bit_str(probs))

