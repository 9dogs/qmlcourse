---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(grovers_algorithm)=

# Алгоритм Гровера

Одно из самых востребованных действий в работе с данными - поиск по базе данных. При использовании классического компьютера такой поиск в худшем случае требует $N$ операций, где $N$ - количество строк в таблице. В среднем найти нужный элемент можно за $N/2$ операций.

Если же наша база данных работает на основе квантовых вычислений, то мы можем применить алгоритм Гровера, и тогда такой поиск потребует всего $\sqrt{N)$ действий. Таким образом, ускорение не будет экспоненциальным, как с некоторыми другими квантовыми алгоритмами, но оно будет квадратичным, что также довольно неплохо.

Итак, мы должны найти идентификационный номер ($Id$) записи, которая удовлетворяет определенным условиям. Функция-оракул находит такую запись (для простоты будем сначала считать, что такая запись одна) и помечает соответствующий ей $Id$. Отметка делается очень оригинальным способом - $Id$ домножается на $-1$.

Для полной ясности соотнесем количество $Id$ с числом кубитов в квантовой схеме. Здесь все очень просто: имея $n$ кубитов, можно закодировать $2^n$ айдишников, то есть $N = 2^n$. К примеру, если в таблице базы данных 1024 записей, то закодировать все $Id$ можно с помощью 10 кубитов.

Для того, чтобы не запутаться в квантовых операциях, рассмотрим пример поменьше: с помощью 2 кубитов закодируем 4 айдишника, один из которых будет помечен функцией-оракулом как искомый - он будет иметь минус. Все 4 числа могут существовать в квантовой схеме, если кубиты приведены в состояние суперпозиции. 

Пусть искомый $Id$ равен 11 (будем пользоваться двоичной системой), тогда после работы функции-оракула мы будем иметь 4 состояния: $|00\rangle$, $|01\rangle$, $|10\rangle$, $-|11\rangle$. Проблема в том, что если измерить эту схему, то с равной вероятностью будет обнаружено одно из этих четырех значений, но узнать, какое из них функция-оракул пометила минусом, будет невозможно.

Получается, что функции-оракула недостаточно, нужно что-то более мощное. На помощь приходит алгоритм Гровера. Правда, у него есть такая особенность - он является итерационным, то есть определенные операции (в том числе и применение функции-оракула) нужно повторить несколько раз (около $\sqrt{N}$). Причем, с количеством итераций нельзя ошибиться, иначе алгоритм даст неправильный ответ.

В идеале после всех итераций квантовую схему можно будет измерить и получить значение $Id$ искомой записи в таблице базы данных.

Разберем операции, которые включает в себя каждая итерация.

Но перед этим добавим в схему еще один кубит, который мы будем называть вспомогательным. Он нужен для хранения метки искомого индекса. Звучит не совсем понятно, но ничего сложного в этом нет, все станет ясным после разбора работы функции-оракула.

В самом начале, еще до всех итераций, все кубиты (включая вспомогательный) должны быть приведены в состояние суперпозиции с помощью оператора Адамара. Причем начальное состояние всех кубитов должно быть равно 0, кроме вспомогательного кубита - он должен быть в состоянии 1.

Таким образом, вспомогательный кубит после применения оператора Адамара будет находиться в состоянии $\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$, тогда как остальные кубиты примут состояние $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$.

Далее начинаем итерации. Каждая итерация состоит из двух частей. Первая часть - это действие функции-оракула. Эта функция знает, какой индекс соответствует искомому объекту, но не может сообщить нам этот индекс напрямую. Зато она может пометить этот индекс.

Для разбора внутренней работы алгоритма нам потребуется задать функцию-оракул вручную, но в рабочих условиях ее устройство как правило не будет для нас известным. Для того чтобы понять алгоритм Гровера, мы должны будем понять, какие изменения происходят с состояниями кубитов до того момента, когда производится измерение, выдающее искомый индекс.

Мы договорились, что в нашей учебной задаче искомый $Id$ равен 11. Так что в результате измерения мы должны получить именно это значение. Смоделируем оракул, который будет помечать этот индекс. В качестве такого оракула подойдет гейт Тоффоли (CCNOT). При подаче на оба его управляющих входа значений 1, он будет применять к управляемому кубиту (это как раз будет вспомогательный кубит) гейт X.

На состояния верхних кубитов, кодирующих индексы 00, 01 и 10 гейт Тоффоли не будет реагировать, и вспомогательный кубит будет находиться в состоянии $\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$.

Но при срабатывании гейта на индексе 11 к вспомогательному кубиту применится оператор X, так что вспомогательный кубит примет состояние $\frac{1}{\sqrt{2}}(|1\rangle - |0\rangle)$, или, если это состояние записать по-другому, за скобками появится минус: $-\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$.

Этот минус относится не только к вспомогательному кубиту, но и ко всему состоянию, соответствующему индексу 11, так что можно считать, что вспомогательный кубит остался неизменнным и отнести минус к состоянию 11 верхних кубитов. Таким образом, индекс 11 помечен минусом как искомый.

Запишем состояние квантовой схемы после применения оракула (состояние вспомогательного кубита - скобка справа):

$\psi = \frac{1}{2\sqrt{2}}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)(|0\rangle - |1\rangle)$

Итак, первая часть первой итерации завершена. Искомый индекс помечен, но если измерить кубиты прямо сейчас, то это ничего не даст - минус не проявит себя при измерении. Да и сам индекс 11 будет получен только с вероятносью 0.25 - такой же, как и у других индекесов.

Для того, чтобы лучше понять дальнейшие действия, запечатлим этот момент работы алгоритма в виде рисунка, показывающего вектор текущего состояния.

...

Мы разобрали случай, когда требуется найти один объект в таблице. Если же потребуется найти несколько объектов, то тогда, обозначив их количество за K, мы должны будем проделать $\sqrt {\frac{N}{K}}$ итераций. Также потребуется не один а несколько вспомогательных кубитов - по одному на каждый индекс, который нужно пометить.
