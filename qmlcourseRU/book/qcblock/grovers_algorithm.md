---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(grovers_algorithm)=

# Алгоритм Гровера

Одно из самых востребованных действий в работе с данными - поиск по базе данных. При использовании классического компьютера такой поиск в худшем случае требует $N$ операций, где $N$ - количество строк в таблице. В среднем найти нужный элемент можно за $N/2$ операций.

Если же наша база данных работает на основе квантовых вычислений, то мы можем применить алгоритм Гровера, и тогда такой поиск потребует всего $\sqrt{N}$ действий. Таким образом, ускорение не будет экспоненциальным, как с некоторыми другими квантовыми алгоритмами, но оно будет квадратичным, что также довольно неплохо.

Итак, мы должны найти идентификационный номер ($Id$) записи, которая удовлетворяет определенным условиям. Функция-оракул находит такую запись (для простоты будем сначала считать, что такая запись одна) и помечает соответствующий ей $Id$. Отметка делается очень оригинальным способом: $Id$ домножается на $-1$.

Для полной ясности соотнесем количество $Id$ с числом кубитов в квантовой схеме. Здесь все очень просто: имея $n$ кубитов, можно закодировать $2^n$ айдишников, то есть $N = 2^n$. К примеру, если в таблице базы данных $1024$ записей, то закодировать все $Id$ можно с помощью десяти кубитов.

Для того, чтобы не запутаться в квантовых операциях, рассмотрим пример поменьше: с помощью двух кубитов закодируем $4$ айдишника, один из которых будет помечен функцией-оракулом как искомый - он будет иметь минус. Все $4$ числа могут существовать в квантовой схеме одновременно, если кубиты приведены в состояние суперпозиции. 

Пусть искомый $Id$ равен $11$ (будем пользоваться двоичной системой), тогда после работы функции-оракула мы будем иметь $4$ состояния: $|00\rangle$, $|01\rangle$, $|10\rangle$, $-|11\rangle$. Проблема в том, что если измерить эту схему, то с равной вероятностью будет обнаружено одно из этих четырех значений, но узнать, какое из них функция-оракул пометила минусом, будет невозможно.

Получается, что одной функции-оракула недостаточно, нужно что-то дополнительное. На помощь приходит алгоритм Гровера. Правда, у него есть такая особенность - он является итерационным, то есть определенные операции (в том числе и применение функции-оракула) нужно повторить несколько раз (около $\sqrt{N}$). Причем, с количеством итераций нельзя ошибиться, иначе алгоритм даст неправильный ответ.

В идеале после всех итераций квантовую схему можно будет измерить и получить значение $Id$ искомой записи в таблице базы данных.

Разберем операции, которые включает в себя каждая итерация.

Но перед этим добавим в схему еще один кубит, который мы будем называть вспомогательным. Он нужен для хранения метки искомого индекса. Звучит не совсем понятно, но ничего сложного в этом нет, все станет ясным после разбора работы функции-оракула.

В самом начале, еще до всех итераций, все кубиты (включая вспомогательный) должны быть приведены в состояние суперпозиции с помощью оператора Адамара. Причем начальное состояние всех кубитов должно быть равно $0$, кроме вспомогательного кубита - он должен быть в состоянии $1$.

Таким образом, вспомогательный кубит после применения оператора Адамара будет находиться в состоянии $\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$, тогда как остальные кубиты примут состояние $\frac{1}{\sqrt{2}}(|0\rangle + |1\rangle)$.

Далее начинаем итерации. Каждая итерация состоит из двух частей. Первая часть - это действие функции-оракула. Эта некоторая функция, умеющая эффективно определять, какой индекс соответствует искомому объекту. Эта функция не может сообщить нам этот индекс напрямую, зато она может его пометить минусом.

Для разбора внутренней работы алгоритма нам потребуется задать функцию-оракул вручную и сделать ее достаточно простой, поэтому нужно знать, что в рабочих условиях она будет действовать похоже, но будет устроена, скорее всего, по-другому, так как будет предназначена для для конкретной задачи выбора искомых данных. Мы не будем касаться вопроса реализации функции-оракула для выбора этих данных, так как это уже другой вопрос, не влияющий на принцип алгоритма Гровера. 

Для того чтобы понять алгоритм Гровера, мы должны будем понять, какие изменения происходят с состояниями кубитов до того момента, когда производится измерение, выдающее искомый индекс.

Мы договорились, что в нашей учебной задаче искомый $Id$ равен $11$, так что в результате измерения мы должны получить именно это значение. Смоделируем оракул, который будет помечать этот индекс. В качестве такого оракула подойдет гейт Тоффоли ($CCNOT$). При подаче на оба его управляющих входа значений 1, он будет применять к управляемому кубиту (это как раз будет вспомогательный кубит) гейт X.

На состояния верхних кубитов, кодирующих индексы $00$, $01$ и $10$ гейт Тоффоли не будет реагировать, и вспомогательный кубит будет находиться в состоянии $\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$.

Но при срабатывании гейта на индексе $11$ к вспомогательному кубиту применится оператор X, так что вспомогательный кубит примет состояние $\frac{1}{\sqrt{2}}(|1\rangle - |0\rangle)$, или, если это состояние записать по-другому, за скобками появится минус: $-\frac{1}{\sqrt{2}}(|0\rangle - |1\rangle)$.

Этот минус относится не только к вспомогательному кубиту, но и ко всему состоянию, соответствующему индексу $11$, так что можно считать, что вспомогательный кубит остался неизменнным, и отнести минус к состоянию $11$ верхних кубитов. Таким образом, индекс $11$ помечен минусом как искомый.

Запишем состояние квантовой схемы после применения оракула (состояние вспомогательного кубита - скобка справа):

$|\psi\rangle = \frac{1}{2\sqrt{2}}(|00\rangle + |01\rangle + |10\rangle - |11\rangle)(|0\rangle - |1\rangle)$

Итак, первая часть первой итерации завершена. Искомый индекс помечен, но если измерить кубиты прямо сейчас, то это ничего не даст - минус не проявит себя при измерении. Да и сам индекс $11$ будет получен только с вероятносью $0.25$ - такой же, как и у других индексов.

Для того, чтобы лучше понять дальнейшие действия, первую половину работы алгоритма в виде рисунка, показывающего вектор текущего состояния. В качестве единичного вектора горизонтальной оси мы будем использовать все состояния из суперпозиции кроме того, который соответствует искомому индексу, а вертикальным единичным вектором будет искомый вектор. 

Вектор $c$ - состояние системы перед первой итерацией - является линейной комбинацией векторов, соответствующим горизонтальной и вертикальной осям.

```{figure} /_static/qcblock/grovers_algorithm/grover_1.png
:name: grover_1
:width: 400px

Схема 1.
```

Можно выразить вектор $c$ для нашего случая (системы из двух кубитов с искомым индексом $11$), обозначив его координаты за $x$ и $y$:

$\frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = x \frac{1}{\sqrt{3}}(|00\rangle + |01\rangle + |10\rangle) + y |11\rangle$

Из данного уравнения находим:

$x = \frac{\sqrt{3}}{2}$

$y = \frac{1}{2}$

По данным координатам можно понять, что угол между вектором $с$ и горизонтальной осью (обозначим его как $\theta$) равен $\frac{\pi}{6}$. Если забежать немного вперед, то можно сказать, что наша цель - добиться, чтобы текущее состояние дошло до $\frac{\pi}{2}$ (или хотя бы приблизительно), то есть почти или полностью равнялось искомому состоянию, так что после измерения можно было его и получить с высокой вероятностью.

Координаты текущего вектора состояния можно записать через угол $\theta$:

$x = cos \theta$

$y = sin \theta$

На всякий случай нужно уточнить, что вспомогательный кубит не отражается на рисунке с окружностью, так как он не предназначен для обозначения индекса, а только хранит в себе его метку.

После применения функции-оракула текущий вектор отразится относительно горизонтальной оси. Объясняется это очень легко - его вертикальная компонента (вектор $|11\rangle$) становится отрицательной.

Вектор $c_{1a}$ - это отражение вектора $c$ относительно горизонтальной оси. Теперь вектор состяния отражается на угол $\theta$, но уже вниз от горизонтальной оси:

```{figure} /_static/qcblock/grovers_algorithm/grover_1a.png
:name: grover_1a
:width: 400px

Схема 2.
```

Такое отражение в нашем примере производится с помощью операции $CCNOT$, но в общем случае операция выглядит так: 

$U_{1a} = I - 2|b\rangle \langle b|$

Функцию-оракул мы здесь обозначили как $U_{1a}$. Она меняет знак только для вертикальной составляющей вектора состояния, поэтому и происходит отражение.

Проверим формулу в действии, применив ее для нашего примера:

$U_{1a} |c\rangle = (I - 2|11\rangle \langle 11|) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle + |11\rangle) = \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle + |11\rangle - 2|11\rangle) = \frac{1}{2} (|00\rangle + |01\rangle + |10\rangle - |11\rangle)$

И наконец приступаем к разбору второй части первой итерации. В ней будет происходить еще одно отражение вектора, но уже не относительно горизонтальной оси, а относительно вектора $c$. Нетрудно заметить, что при этом текущий вектор состояния станет равен $cos(3 \theta)|a\rangle + sin(3 \theta)|b\rangle$.

```{figure} /_static/qcblock/grovers_algorithm/grover_1b.png
:name: grover_1b
:width: 400px

Схема 3.
```

Операция получения вектора $c_{1b}$ будет выглядеть так:

$U_{1b} = 2|c\rangle \langle c| - I$

Посчитаем, чему равен вектор $c_{1b}$ для нашего примера:

$U_{1b} |c_{1a}\rangle = (2|c\rangle \langle c| - I) \frac{1}{2}(|00\rangle + |01\rangle + |10\rangle - |11\rangle) = |11\rangle$

По рисунку видно, что в общем случае каждая последующая итерация будет приближать текущий вектор к вертикальному. Но в нашем случае угол между вектором состояния и горизонтальной осью после окончания первой итерации равен $3 \theta$, то есть это уже и есть желаемый угол $\frac{\pi}{2}$.

В общем случае этот угол равен $(2i + 1) \theta$, где $i$ - номер итерации. Отсюда можно вывести число итераций, необходимое для работы алгоритма: это приблизительно $\sqrt{N}$ при стремлении $\theta$ к $0$.

Мы разобрали случай, когда требуется найти один объект в таблице. Если же потребуется найти несколько объектов, то тогда, обозначив их количество за K, мы должны будем проделать около $\sqrt {\frac{N}{K}}$ итераций.
