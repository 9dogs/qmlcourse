---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(deutschs_algorithm)=

# Задача Дойча

Задача Дойча (в английском варианте - Deutsche's algorithm) - это один из первых алгоритмов, показавших, что квантовый компьютер может решать задачи особым способом, отличающимся как от алгоритмов классического компьютера, так и от интуиции и здравого смысла человека. При этом такое решение может занимать меньшее количество шагов. 

Нужно прежде всего сказать, что задача Дойча не имеет практического применения, зато она является простейшим примером, с помощью которого можно понять, в чем состоит отличие квантовых алгоритмов от классических. Данный алгоритм был предложен в 1985 году, когда квантовых компьютеров еще не было, а практически он был реализован в 1998 году на 2-кубитном квантовом компьютере, работавшем на принципах ядерно-магнитного резонанса.

Итак, в чем состоит задача, которую решает алгоритм? Представьте, что у вас есть функция, которая представляет собой "черный ящик", принимающий на вход число из множества {0, 1}. Функция неким образом обрабатывает входное значение и возвращает число из этого же множества, то есть либо 0, либо 1. Нам известно, что эта функция принадлежит либо к классу сбалансированных функций, либо к классу константных функций (которые мы также можем называть несбалансированными). Задача алгоритма - установить, к какому классу принадлежит функция.

Рассмотрим все варианты этих двух классов функций. Всего их четыре, то есть по две функции в каждом классе. Начнем с несбалансированных:
<br/>
<br/>
<b>1). f<sub>1</sub>(x) = 0</b>
<br/>
Это функция, всегда возвращающая 0, независимо от входного значения. Для нее справедливы выражения: 
<br/>
f<sub>1</sub>(0) = 0
<br/>
f<sub>1</sub>(1) = 0
<br/>

<b>2). f<sub>2</sub>(x) = 1 </b>
<br/>
Такая функция всегда возвращает 1, то есть верно следующее: 
<br/>
f<sub>2</sub>(0) = 1
<br/>
f<sub>2</sub>(1) = 1
<br/>

Ну а теперь посмотрим на сбалансированные функции. Для них характерно то, что они могут возвращать как 0, так и 1. В этом и заключается "баланс".
<br/>
<br/>
<b>3). f<sub>3</sub>(x) = x </b>
<br/>
Это тождественная функция, которая ничего не делает с входным значением. Для нее справедливо следующее:
<br/>
f<sub>3</sub>(0) = 0
<br/>
f<sub>3</sub>(1) = 1
<br/>

<b>4). f<sub>4</sub>(x) = NOT x</b>
<br/>
А вот эта функция инвертирует входное значение, то есть возвращает не то число, которое было подано на вход, а другое:
<br/>
f<sub>4</sub>(0) = 1
<br/>
f<sub>4</sub>(1) = 0
<br/>

Классический компьютер справляется с задачей за два шага. Например, нам дана некоторая функция-"черный ящик", и мы должны установить, сбалансирована ли она.
На первом шаге мы отправляем в функцию входное значение 0. Допустим, мы получили на выходе также 0. Мы можем сказать, что данная функция - либо f<sub>1</sub>
(константная функция, всегда возвращающая 0), либо <sub>3</sub> (сбалансированная функция, не меняющая входное значение). Для окончательного решения мы должны сделать еще один шаг - отправить в функцию значение 1. Если при этом мы получим опять 0, то это функция f<sub>1</sub>, а если получили на выходе 1, то искомая функция - f<sub>3</sub>.

Способа, с помощью которого на классическом компьютере можно за одно действие установить, сбалансирована функция или нет, не существует. И здесь свое преимущество показывает квантовый компьютер: он может установить класс функции за одно действие.

Для начала рассмотрим простейшую схему, с помощью которой можно отправлять число на вход и получать ответ от черного ящика:
<br/>
```{figure} /_static/qcblock/deutschs_algorithm/scheme_1.png
:name: scheme_1
:width: 400px
```
<br/>
Неизвестная функция обозначена как U<sub>f</sub>. Обратите внимание, что в этой схеме используются два кубита. Это нужно для того, чтобы информация, с которой работает квантовый компьютер, не стиралась. В квантовом компьютере важно, чтобы все действия с кубитами (кроме операции измерения) были обратимыми, а для этого информация должна сохраняться. В верхнем кубите (x) будет записано входное значение, а в нижнем (y) - выходное значение функции. Таким образом, входное значение не будет перезаписано значением, которое вернет функция.

Но нам важно будет не только сохранить значение x, но также и не разрушить y. Так как кубит y очевидно имеет некоторое изначальное значение, мы не можем его просто перезаписать тем числом, которое выдаст функция. Здесь на помощь приходит операция XOR (исключающее ИЛИ, сложение по модулю 2), обозначенная на схеме как плюс внутри круга. Мы применим ее к значениям y и f(x). Операции XOR соответствует такая таблица истинности:

| a | b | a XOR b |
|:-:|:-:|:-------:|
| 0 | 0 | 0       |
| 0 | 1 | 1       |
| 1 | 0 | 1       |
| 1 | 1 | 0       |

Операция XOR хороша для нас тем, что она не разрушает значение y, так как можно восстановить y, повторно применив XOR. Убедиться в этом можно, проверив тождество:
<br/>
(a XOR b) XOR b = a
<br/>

Схема 1 пока что не дает преимущества по сравнению с классическим компьютером, но мы можем ее немного усовершенствовать:
<br/>
<br/>
```{figure} /_static/qcblock/deutschs_algorithm/scheme_2.png
:name: scheme_2
:width: 500px
```
<br/>
<br/>
В новой схеме оба кубита вначале будут находиться в состоянии 0. Затем мы применим к верхнему кубиту оператор Адамара, а к нижнему - гейт X, а затем так же, как и к верхнему, оператор Адамара. Тем самым мы приведем оба кубита в состояние суперпозиции перед тем, как они попадут на вход функции U<sub>f</sub>.
