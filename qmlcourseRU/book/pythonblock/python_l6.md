---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(python_l6)=

# Списки и циклы в Python

## Описание лекции

На этом занятии мы разберем следущие темы:

- списки (`list`) и их методы;
- индексация списков;
- что такое срезы и зачем они нужны;
- цикл `for` и функция `range`;
- итерация по спискам, list comprehensions.

## Введение в списки объектов
В предыдущих уроках мы оперировали малым количеством переменных. Для каждого блока логики или примера кода вводилось 3-5 объектов, над которыми осуществлялись некоторые операции. Но что делать, если объектов куда больше? Скажем, вам необходимо хранить информацию об учащихся класса - пусть это будет рост, оценка по русскому языку или что-либо другое. Не знаю как вы, но я нахожу крайне неудобным создание 30 отдельных переменных. А если еще и нужно посчитать среднюю оценку в классе! 

```python
average_grade = petrov_math + kosareva_math + zinchenko_math + kotenkov_math + ...
average_grade = average_grade / 30
```

Такой код к тому же получается крайне негибким: если количество студентов, как и их состав, изменится, то нужно и формулу переписать, так еще и делитель - в нашем случае 30 - изменять. 

Часто в программах - даже в (квантовом) машинном обучении - приходится работать с большим количество __однотипных__ переменных. Специально при этого придуманы **массивы** (по английски array). В Python их еще называют **списками** (list). В некоторых языках программирования эти понятия отличаются, но не в Python. Список может хранить переменные **разного** типа. Для создания простого списка необходимо указать квадратные скобки или вызвать конструктор типа (`list` - это отдельный тип, фактически такой же, как int или str), а затем перечислить **объекты через запятую**:

```{code-cell} ipython3
# разные способы объявления списков
first_list = []
second_list = list()
third_list = list(1,2, 'stroka', 3.14)
fourth_lust = [15, 2.2, ['another_list', False]]

print(type(second_list), type(fourth_lust))
print(first_list, fourth_lust)
```

```{tip}
Хоть список и хранит переменные разного типа, но так делать без особой необходимости не рекомендуется - вы сами скорее запутаетесь и ошибетесь в обработке объектов списка. В большинстве других языков прогрммирования массив может хранить только объекты одного типа
```

Теперь можно один раз создать список и работать с ним как с единым целым. Да, по прежнему для заведения оценок студентов придется разово их зафиксировать, но потом куда проще исправлять и добавлять! Рассмотрим пример нахождения средней оценки группы, в которой всего 3 учащихся, но к ним присоединили еще 2, а зетем - целых 5:

```{code-cell} ipython3
# базовый журнал с тремя оценками
math_journal = [3, 3, 5]

# добавим новопришедших студентов
math_journal.append(4)
math_journal.append(5)

# и сразу большую группу новых студентов
math_journal.extend([2,3,4,5,5])

print(math_journal)

# найдем среднюю оценку как сумму всех оценок, деленную на их количество 
avg_grade = sum(math_journal) / len(math_journal)
print(avg_grade)
```

В коде выше продемонстрированно сразу несколько важных аспектов:
1. Добавлять по одному объекту в конец списка можно с помощью метода списка `append`;
2. Метод `append` принимает в качестве аргумента один Python-объект;
3. Слияние списков (конкатенация, прямо как при работе со строками) нескольких осуществляется командой `extend` (расширить в переводе с английского);
4. Для списков определена функция `len`, которая возвращает целое число `int` - количество объектов в списке;
5. Функция `sum` может применяться к спискам для суммирования всех объектов (если позволяет тип - то есть для `float`, `int` и `bool`. Попробуйте разобраться самостоятельно, как функция работает с последним указанным типом);
6. Для методов `append` и `extend` не нужно приравнивать результат выполнения какой-то переменной - изменится сам объект, у которого был вызван метод (в данном случае это `math_journal`);
7. Списки в Python **упорядочены**, то есть объекты сами по себе места не меняют, и помнят, в каком порядке были добавлены в массив. 

```{tip}
В тексте выше встречается термин **метод**, который, быть может, вам не знаком. По сути метод - это такая же **функция**, о которых мы говорили раньше, но она принадлежит какому-то объекту с определенным типом. Не переживайте, если что-то непонятно - про функции и методы мы поговорим подробно в ближайших лекциях!

`print`, `sum` - функции, они существуют сами по себе;
`append`, `extend` - методы объектов класса `list`, не могут использовать без них.
```

## Индексация списков
Теперь, когда стало понятно, с чем предстоит иметь дело, попробуем усложнить пример. Как узнать, какая оценка у третьего студента? Все просто - нужно воспользоваться **индексацией** списка:

```{code-cell} ipython3
# базовый журнал с пятью оценками
math_journal = [1, 2, 3, 4, 5]

third_student_grade = math_journal[3]
print(third_student_grade)
```

И снова непонятный пример! Давайте разбираться:
1. Для обращения к `i`-тому объекту нужно в квадратных скобках указать его индекс;
2. **Индекс** в Python начинается **С НУЛЯ** - это самое важное и неочевидное, здесь чаще всего случаются ошибки;
3. Поэтому `[3]` обозначает взятие **четвертой** оценки (и потому выводится четверка, а не тройка);
4. Всего оценок 5, но так как индексация начинается с нуля, то строчка `math_journal[5]` выведет ошибку - нам доступны лишь индексы `[0, 1, 2, 3, 4]` для взятия (так называется процедура обращения к элементу списка по индексу - взятие по индексу).

```{figure} /_static/pythonblock/list_loops_l6/list_indexing_1.png
:name: list_indexing
:width: 400px

Пример списка из трех объектов. Сверху показаны их индексы, включая отрицательные
```

Также в `Python` существуют отрицательные индексы (-1, -2 ...). Они отсчитывают объекты списка, начиная с конца. Так как нуль уже занят (под первый объект), то он не используется.

```{code-cell} ipython3
# базовый журнал с пятью оценками
math_journal = [1, 2, 3, 4, 5]

# возьмем последнюю оценку
last_grade = math_journal[-1]
print(last_grade)

# а теперь - предпоследнюю
prev = math_journal[-2]
print(prev)

# конечно, взятие по индексам можно использовать в ранее разобранном синтаксисе

if math_journal[-1] < math_journal[-2]:
    math_journal[-1] += 1
    print("Последняя оценка меньше предпоследней. Натянем студенту?")
else:
    math_journal[-2] = 2
    print("Последний студент сдал очень хорошо, на его фоне предпоследний просто двоечник!")
```

Все это важно не только для грамотного оперирования конкретными объектами, но и следующей темы - 

## Срезы
Срезы, или slices - это механизм обращения сразу к нескольким объектам списка. Для создания среза нужно в квадратных скобках указать двоеточие, слева от него - индекс начала среза (по умолчанию 0, можно не выставлять) **включительно**, справа - границу среза **не включительно** (пустота означает "до конца списка"). Может показаться нелогичной такая разнородность указания границ, но на самом деле она безумно удобна - особенно вместе с тем, что индексация начинается с нуля. Быстрее объяснить на примере: 

```{code-cell} ipython3
# базовый журнал с пятью оценками
math_journal = [1, 2, 3, 4, 5]

# как взять первые 3 оценки?
first_3_grades = math_journal[:3]
print(first_3_grades)

# как взять последние две оценки?
last_2_grades = math_journal[-2:]
print(last_2_grades)

# сделаем срез на 4 оценки, начиная со второй (с индексом 1)
start_index = 1
some_slice = math_journal[start_index : start_index + 4]
print(some_slice)
```

```{tip}
Можно сделать пустой срез, и тогда Python вернет пустой список без объектов. Можете проверить сами:
`['1', '2', '3'][10:20]`
```


Давайте проговорим основные моменты, которые **крайне важно понять**:
1. Так как индексация начинается с нуля (значение по умолчанию), и правая граница не включается в срез, то берутся объекты с индексами `[0,1,2]`, что в точности равняется трем первым объектам;
2. Срез `[-2:]` указывает на то, что нужно взять все объекты до конца, начиная с предпоследнего
3. Значения в срезе могут быть **вычислимы** (и задаваться сколь угодно сложной формулой), но должны оставаться **целочисленными**;
4. Если нужно взять `k` объектов, начиная с `i`-го индекса, то достаточно в качестве индекса конца среза указать `k+i`.

