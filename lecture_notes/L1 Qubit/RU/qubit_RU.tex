% Created 2021-03-06 Sat 12:31
% Intended LaTeX compiler: xelatex
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{polyglossia}
\setotherlanguage{russian}
\usepackage{amsmath}
\usepackage{physics}
\setmainlanguage{russian}
\setotherlanguage{english}
\setmainfont{Times New Roman}
\usepackage{amsmath}
\usepackage{physics}
\usepackage{graphicx}
\usepackage{hyperref}
\author{Семен Синченко}
\date{\today}
\title{Кубит}
\hypersetup{
 pdfauthor={Семен Синченко},
 pdftitle={Кубит},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.5)}, 
 pdflang={Russian}}
\begin{document}

\maketitle
\tableofcontents


\section{Описание лекции}
\label{sec:org902b36f}
Из этой лекции мы узнаем:
\begin{itemize}
\item Что такое кубит
\item В чем разница между значением и состоянием
\item Что такое сфера Блоха
\item Какие можно делать операции над кубитами
\item Что такое измерение
\end{itemize}

\section{Что такое кубит}
\label{sec:org9682074}

Как мы знаем, классический компьютер оперирует двоичными числами (0 и 1). Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами, или кубитами. Если мы будем считывать кубит, то он также как и классический бит, будет иметь лишь два возможных значения (0 и 1). Так в чем же разница с обычным битом? В чем особенности квантовых компьютеров, которые и дают им преимущества над классическими компьютерами?

Вся суть на самом деле в том, что для квантомеханичеких систем (и кубитов в частности) их \textbf{состояния} и \textbf{значения} это не одно и то же!

\section{Состояние vs значение}
\label{sec:org8b4dd4c}

\subsection{Состояние классического бита}
\label{sec:org427ea79}
Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение \(\mathbf{1}\), то и состояние его описывается числом \(\mathbf{1}\).

\subsection{Кот Шрёдингера}
\label{sec:org989debc}
Давайте вспомним известный мысленный эксперимента Шрёдингера -- кот, который одновременно и жив и мертв. Понятно, что \textbf{значение} кота точно одно - он либо жив, либо мертв. Но \textbf{состояние} его более сложное -- он находится в \textbf{суперпозиции} состояний жив и мертв одновременно!

\begin{center}
\begin{figure}[htbp]
\centering
\includegraphics[width=0.6\textwidth]{./images/Schrodingers_cat.svg.png}
\caption{Кот Шрёдингера}
\end{figure}
\end{center}

\subsection{Состояние кубита}
\label{sec:org09c6180}
Состояние кубита, если можно так сказать, аналогично коту Шрёдингера: оно отличается от значения кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом \(\ket{\Psi}\) (кет -- вектор-столбец) -- это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
c_1 \\
c_2
\end{bmatrix}
\end{align*}

Что именно значат числа \(c_1\) и \(c_2\) мы поговорим чуть далее, а пока запишем наш кубит \(\ket{\Psi}\) в коде Python. Возьмем, для начала, \(c_1 = c_2 = \frac{1}{\sqrt{2}}\).

\begin{verbatim}
import numpy as np

qubit = np.array([1 / np.sqrt(2) + 0j, 1 / np.sqrt(2) + 0j]).reshape((2, 1))
\end{verbatim}
Заметьте, что здесь мы создаем именно вектор-строку размерности \(2\times1\).
\begin{verbatim}
qubit.shape
# (2, 1)
\end{verbatim}

\subsection{Связь состояния и значения кубита}
\label{sec:org55322c4}
А теперь разберем подробнее, что же такое наш вектор \(\ket{\Psi}\) и что же значат цифры \(c_1, c_2\). Для начала посмотрим на то, а какие состояния имеет кубит, для которого мы точно знаем значение. То есть посмотрим на кота Шрёдингера, но который точно жив или точно мертв.

\subsubsection{Базисные состояния}
\label{sec:org443ea8c}
Посмотрим, как выглядят состояния кубитов со точно определенными значениями:
\begin{align*}
\ket{0} = \begin{bmatrix}1 + 0j \\ 0 + 0j\end{bmatrix} \text{\qquad} \ket{1} = \begin{bmatrix}0 + 0j \\ 1 + 0j\end{bmatrix}
\end{align*}

Что мы можем сказать об этих состояниях? Как минимум следующее:
\begin{itemize}
\item Они ортогональны (\(\ket{0} \perp \ket{1}\))
\item Они имеют единичную норму
\item Они образуют базис
\end{itemize}

Что это значит для нас? А то, что любое состояние \(\ket{\Psi}\) мы можем записать как линейную комбинацию векторов \(\ket{0}\) и \(\ket{1}\), причем коэффициенты в этой комбинации будут как раз наши \(c_1, c_2\):

\begin{verbatim}
basis_0 = np.array([1 + 0j, 0 + 0j]).reshape((2, 1))
basis_1 = np.array([0 + 0j, 1 + 0j]).reshape((2, 1))

c1 = c2 = 1 / np.sqrt(2)

np.allclose(qubit, c1 * basis_0 + c2 * basis_1)
# True
\end{verbatim}

\subsubsection{Амплитуды вероятностей}
\label{sec:org37b4225}
Квантовая механика устроена таким интересным образом, что если мы будем измерять \textbf{значение} кубита, то вероятность каждого из вариантов будет пропорциональная соответствующему коэффициенту в разложении \textbf{состояния}. Но так как амплитуды у нас это в общем случае комплексные числа, а вероятности должны быть строго действительные, мы должны домножить амплитуды на комплексно сопряженные значения. В случае наших значений \(c_1 = c_2 = \frac{1}{\sqrt{2}}\) мы получаем:
\begin{verbatim}
p0 = np.conj(c1) * c1
p1 = np.conj(c2) * c2

np.allclose(p0, p1)
# True

np.allclose(p0 + p1, 1.0)
# True
\end{verbatim}

Тут мы сразу видим еще одну важную вещь -- сумма вероятностей всех состояний должна быть равна 100\%. Это сразу приводит нас к тому, что состояния это не любые комплексные вектора, а комплексные вектора с единичной нормой:

\begin{verbatim}
np.allclose(np.conj(qubit).T @ qubit, 1.0)
# True
\end{verbatim}

Мы будем очень часто пользоваться транспонирование и взятием комплексно сопряженного от векторов и в квантовой механике это имеет специальное обозначение \(\bra{\Psi} = \Psi^{T\dagger}\) (бра -- вектор-строка). Тогда наше правило нормировки из NumPy кода может быть записано в нотации Дирака так:
\begin{align*}
\bra{\Psi}\ket{\Psi} = 1
\end{align*}

\section{Сфера Блоха}
\label{sec:org28e4257}
Надо понимать, что описанный нами выше базис \(\ket{0}, \ket{1}\) не является единственно возможным базисом. Наши вектора \(\ket{0}, \ket{1}\) это лишь самый часто применимый базис, который называют \(\mathbf{Z}\) базисом. Но есть и другие варианты.


\subsection{Возможные базисы}
\label{sec:org1a40461}
\subsubsection{Z-базис}
\label{sec:org40159e3}
Уже описанные нами \(\ket{0}\) и \(\ket{1}\).

\subsubsection{X-базис}
\label{sec:org5802603}
Базисные состояния \(\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}\) и \(\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}\):
\begin{verbatim}
plus = (basis_0 + basis_1) / np.sqrt(2)
minus = (basis_0 - basis_1) / np.sqrt(2)
\end{verbatim}

\subsubsection{Y-базис}
\label{sec:org473ee1e}
Базисные состояния \(\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}\) и \(\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}\):
\begin{verbatim}
R = (basis_0 + 1j * basis_1) / np.sqrt(2)
L = (basis_0 - 1j * basis_1) / np.sqrt(2)
\end{verbatim}

Легко можно убедиться, что все для каждого из этих базисов вектора ортогональны:
\begin{verbatim}
np.allclose(np.conj(basis_0).T @ basis_1, 0)
# True
np.allclose(np.conj(plus).T @ minus, 0)
# True
np.allclose(np.conj(R).T @ L, 0)
# True
\end{verbatim}

Заметьте, что в наших векторных пространствах скалярное произведение это \(ab = \bra{a}\ket{b}\)! Именно поэтому мы должны делать транспонирование и комплексное сопряжение первого вектора в паре.

\subsection{Сфера Блоха}
\label{sec:orga35a297}
Обозначения \(\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}\) выбраны не случайно -- они имеют геометрический смысл.

\begin{center}
\begin{figure}[htbp]
\centering
\includegraphics[width=0.35\textwidth]{./images/Blochcolor-alt.png}
\caption{Сфера Блоха}
\end{figure}
\end{center}

Принято считать, что ось \(\mathbf{Z}\) это основная ось, так как физически, квантовые компьютеры измеряют именно по этой оси. Ось \(\mathbf{X}\) она, если можно так выразиться, смотрит на нас и поэтому обозначается \(\ket{+}\) и \(\ket{-}\). А ось \(\mathbf{Y}\) направлена как бы вдоль и поэтому базис обозначают как {}<<право>>{} (\(\ket{R}\)) и {}<<лево>>{} (\(\ket{L}\)).

Вектор состояния кубита также называют волновой функцией и этот вектор может идти в любую точку сферы Блоха. Так как сама сфера имеет единичный радиус, это гарантирует нам, что для всех состояний сумму квадратов амплитуд будет равна единице.

\section{А что можно делать с таким кубитом?}
\label{sec:orgd0e8445}
\subsection{Линейные операторы}
\label{sec:org78eaed1}
Любое наше действие, которое мы совершаем с кубитом в состоянии \(\ket{\Psi}\) должно переводить его в другое состояние \(\ket{\Phi}\). Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица! Ну или, другими словами, линейный оператор. Мы будем обозначать их \(\hat{U}\).

\subsection{Обратимость}
\label{sec:org2590de2}
Наша природа устроена таким образом, что почти все действия, которые мы совершаем с кубитом, должны быть обратимыми. То есть для каждого действия и операции (кроме измерений, но об этом чуть дальше), например \(\hat{U}\), должно быть такое противодействие \(\hat{U^\dagger}\), что оно вернет кубит в первоначальное состояние:
\begin{align*}
\hat{U}^\dagger = \hat{U}^T
\end{align*}

Тут \(\dagger\) обозначает взятие комплексно сопряженного. А такие операторы называются самосопряженными.

\subsection{Унитарность}
\label{sec:orgb87a664}
Как мы говорили, норма волновой функции должна быть нормирована на единицу, а значит любой оператор, который переводит одно состояние в другое \(\hat{U}\ket{\Psi} = \ket{\Phi}\) должен сохранять нормировку, то есть должен быть \textbf{унитарным}. Более того, это свойство приводит к тому, что матрица сохраняет скалярное произведение:

\begin{align*}
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\end{align*}

Другими словами, унитарный оператор удовлетворяет условию \(\hat{U}^\dagger \hat{U} = \hat{I}\)

\subsection{Пример оператора}
\label{sec:org0179b47}
Большое число операторов мы будем разбирать в дальнейших лекция, так как именно операторы (или квантовые \textbf{гейты}) являются основой квантовых вычислений. А пока мы посмотрим один просто пример -- оператор Адамара (Hadamard gate) -- оператор, который переводит \(\ket{0} \to \ket{+}\).

\subsubsection{Гейт Адамара}
\label{sec:org17c59cb}
Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита это вектор размерности два, а значит оператор, который переводит вектор размерности два в другой вектор размерности два это матрица \(2\times 2\). Запишем оператор Адамара в матричном виде, а потом убедимся, что он эрмитов, унитарный, а еще, что он действительно переводит состояние \(\ket{0} \to \ket{+}\).

\begin{align*}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\end{align*}

\begin{enumerate}
\item Реализация в Python
\label{sec:org789bd2e}
\begin{verbatim}
h = 1 / np.sqrt(2) * np.array([
    [1 + 0j, 1 + 0j],
    [1 + 0j, 0j - 1]
])
\end{verbatim}

\item Самосопряженность
\label{sec:orge0b2776}
\begin{verbatim}
np.allclose(np.conj(h), h.T)
# True
\end{verbatim}

\item Унитарность
\label{sec:org0235033}
\begin{verbatim}
np.allclose(np.conj(h) @ h, np.eye(2))
# True
\end{verbatim}

\item Правильное действие
\label{sec:org39c4350}
\begin{verbatim}
np.allclose(h @ basis_0, plus)
# True
\end{verbatim}
\end{enumerate}

\section{Измерения}
\label{sec:orga46289e}
Измерения в квантовых вычислениях стоят отдельно именно потому, что они {}<<открывают>>{} коробку с котом Шрёдингера -- мы точно узнаем, жив он, или мертв. Вся \textbf{суперпозиция} его состояния исчезает.



\textit{Это интересный факт -- исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг "ломаются" и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения мы как бы "расщепляем" нашу вселенную на две ниточки -- в одной кот остается жив, а в другой остается мертв.}

\textit{К сожалению, любые такие теории все равно остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Это скорее вопрос того, как каждый из нас понимает этот процесс, так как математически все такие теории в итоге дают один и тот же результат, который мы можем наблюдать и измерять.}


Как мы уже говорили, у кубита может быть несколько разных базисов: \(\ket{0}, \ket{1}\), \(\ket{+}, \ket{-}\), \(\ket{R}, \ket{L}\). \textbf{Значение} кубита в каждом из этих базисов может быть измерено. Но что такое измерение? Как это записать математически?

\subsection{Операторы Паули}
\label{sec:org6ece396}
На самом деле, любая наблюдаемая величина соответствует какому-то оператору. Например, измерения в разных базисах \mathbf{X}, \mathbf{Y}, \mathbf{Z} соответствуют операторам Паули:

\begin{align*}
\hat{\sigma^x} = \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}\qquad\hat{\sigma^y} = \begin{bmatrix}0 & -i\\i & 0\end{bmatrix}\qquad\hat{\sigma^z} = \begin{bmatrix}1 & 0\\0 & -1\end{bmatrix}
\end{align*}

\begin{verbatim}
pauli_x = np.array([[0 + 0j, 1 + 0j], [1 + 0j, 0 + 0j]])
pauli_y = np.array([[0 + 0j, 0 - 1j], [0 + 1j, 0 + 0j]])
pauli_z = np.array([[1 + 0j, 0 + 0j], [0 + 0j, 0j - 1]])
\end{verbatim}

Эти операторы являются очень важными -- рекомендуется знать их наизусть, так как они встречаются в каждой 2-й статье по квантовым вычислениям, а также постоянно фигурируют в документации всех основных библиотек для квантового машинного обучения!

\subsection{Собственные значения}
\label{sec:orga95b258}
Хорошо, мы поняли, что есть какая-то связь между нашими измерениями и операторами. Но какая именно? Что значит, например, что измерения по оси \(\mathbf{Z}\) соответствуют оператору \(\hat{\sigma^Z}\)?

И тут мы приходим к собственным значениям операторов. Оказывается (так устроен наш мир), что \textbf{измеряя} какую-то величину в квантовой механике мы всегда будем получать одно из собственных значений соответствующего оператора, а состояние будет коллапсировать в соответствующий собственный вектор этого оператора. Другими словами, \textbf{измеряя} кота Шрёдингера мы будем получать значения жив или мёртв, а состояние кота будет переходить в состояние, соответствующее одному из этих значений. А еще \textbf{измерение} не является обратимой операцией -- однажды открыв коробку с котом и увидев, что он жив или мертв, мы уже не сможем закрыть ее обратно и вернуть кота в суперпозицию.

Важно понимать, что это не просто что-то из квантовой физики -- понимание этих вещей нам очень пригодится потом, когда мы будем говорить о решении практических комбинаторных задач, таких, например, как задача о выделении сообществ в графе!

\subsubsection{Собственные вектора \(\hat{\sigma^Z}\)}
\label{sec:org4069709}
Вернемся к нашему оператору \(\hat{\sigma^Z}\). Легко убедиться, что его собственные значения равны 1 и -1, а собственные соответствующие им собственные вектора это \(\begin{bmatrix}1 \\ 0\end{bmatrix}\) и \(\begin{bmatrix}0 \\ 1\end{bmatrix}\):
\begin{verbatim}
np.linalg.eig(pauli_z)
# (array([ 1.+0.j, -1.+0.j]),
# array([[1.+0.j, 0.+0.j],
#        [0.+0.j, 1.+0.j]]))
\end{verbatim}

Таким образом, измерение по оси \(\mathbf{Z}\) всегда будет давать нам одно из этих двух значений и переводить состояние кубита в соответствующий собственный вектор.

\subsection{Формальная запись}
\label{sec:orga4744bb}
Формально мы можем записать это для любого эрмитова оператора \(\hat{U}\), что собственные состояния этого оператора являются его собственными векторами, а собственные значения в этом случае являются наблюдаемыми значениями:
\begin{align*}
\hat{U}\ket{\Psi} = u\ket{\Psi}
\end{align*}

\subsection{Другие операторы Паули}
\label{sec:org2fde0d9}
Убедимся, что у остальных операторов собственные значения такие же:


\begin{verbatim}
np.linalg.eig(pauli_x)
# (array([ 1.+0.j, -1.+0.j]),
# array([[ 0.70710678-0.j,  0.70710678+0.j],
#        [ 0.70710678+0.j, -0.70710678+0.j]]))
\end{verbatim}

\begin{verbatim}
np.linalg.eig(pauli_y)
# (array([ 1.+0.j, -1.+0.j]),
# array([[-0.        -0.70710678j,  0.70710678+0.j        ],
#        [ 0.70710678+0.j        ,  0.        -0.70710678j]]))
\end{verbatim}



\textit{
Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда мы не можем одновременно точно измерить два разных оператора, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется принципом неопределенности.}

\subsection{Ожидаемое значение при измерении}
\label{sec:orgffac7de}
Мы не будем писать полный симулятор кубитов, который включает измерения -- это требует введения сложного случайного процесса. Но мы можем легко ответить на другой вопрос. А именно, мы можем сказать, а какое будет \textbf{ожидаемое} значение оператора \(\hat{U}\) для состояния \(\Psi\)? Ну или, другими словами, какое будет математическое ожидание большого числа измерений. Это можно записать следующим образом:
\begin{align*}
\mathbf{E}(\hat{U}) = \bra{\Psi}\hat{U}\ket{\Psi}
\end{align*}

Например, оператор \(\hat{\sigma^z}\) полностью не определен в состоянии \(\ket{+}\), то есть мы будем равновероятно получать значения -1 и 1, а математическое ожидание будет равно нулю:
\begin{verbatim}
plus.conj().T @ pauli_z @ plus
# array([[0.+0.j]])
\end{verbatim}

С другой стороны, измеряя состояние \(\ket{+}\) в X-базисе мы всегда будем получать 1:
\begin{verbatim}
plus.conj().T @ pauli_x @ plus
# array([[1.+0.j]])
\end{verbatim}

\section{Что мы узнали?}
\label{sec:org27438ed}
\begin{itemize}
\item Состояние и значение для кубита не одно и то же
\item Состояния -- вектора в Гильбертовом пространстве
\item Квантовые операторы унитарные и самосопряженные
\item Измеряемые значения -- собственные значения операторов
\item Измерение ломает суперпозицию
\end{itemize}
\end{document}
