#+TITLE: Кубит
#+AUTHOR: Семен Синченко
#+LANGUAGE: ru
#+LATEX_HEADER: \setmainlanguage{russian}
#+LATEX_HEADER: \setotherlanguage{english}
#+LATEX_HEADER: \setmainfont{Times New Roman}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{physics}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{hyperref}

#+OPTIONS: tex:dvisvgm

* Описание лекции
Из этой лекции мы узнаем:
- Что такое кубит
- В чем разница между значением и состоянием
- Что такое сфера Блоха
- Какие можно делать операции над кубитами
- Что такое измерение

* Что такое кубит

Как мы знаем, классический компьютер оперирует двоичными числами (0 и 1). Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами, или кубитами. Если мы будем считывать кубит, то он также как и классический бит, будет иметь лишь два возможных значения (0 и 1). Так в чем же разница с обычным битом? В чем особенности квантовых компьютеров, которые и дают им преимущества над классическими компьютерами?

Вся суть на самом деле в том, что для квантомеханичеких систем (и кубитов в частности) их *состояния* и *значения* это не одно и то же!

* Состояние vs значение

** Состояние классического бита
Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение $\mathbf{1}$, то и состояние его описывается числом $\mathbf{1}$.

** Кот Шрёдингера
Давайте вспомним известный мысленный эксперимента Шрёдингера -- кот, который одновременно и жив и мертв. Понятно, что *значение* кота точно одно - он либо жив, либо мертв. Но *состояние* его более сложное -- он находится в *суперпозиции* состояний жив и мертв одновременно!

#+begin_center
#+caption: Кот Шрёдингера
#+attr_latex: :width 0.6\textwidth
[[./images/Schrodingers_cat.svg.png]]
#+end_center

** Состояние кубита
Состояние кубита, если можно так сказать, аналогично коту Шрёдингера: оно отличается от значения кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом $\ket{\Psi}$ (кет -- вектор-столбец) -- это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
c_1 \\
c_2
\end{bmatrix}
\end{align*}

Что именно значат числа $c_1$ и $c_2$ мы поговорим чуть далее, а пока запишем наш кубит $\ket{\Psi}$ в коде Python. Возьмем, для начала, $c_1 = c_2 = \frac{1}{\sqrt{2}}$.

#+begin_src python
import numpy as np

qubit = np.array([1 / np.sqrt(2) + 0j, 1 / np.sqrt(2) + 0j]).reshape((2, 1))
#+end_src
Заметьте, что здесь мы создаем именно вектор-строку размерности $2\times1$.
#+begin_src python
qubit.shape
# (2, 1)
#+end_src

** Связь состояния и значения кубита
А теперь разберем подробнее, что же такое наш вектор $\ket{\Psi}$ и что же значат цифры $c_1, c_2$. Для начала посмотрим на то, а какие состояния имеет кубит, для которого мы точно знаем значение. То есть посмотрим на кота Шрёдингера, но который точно жив или точно мертв.

*** Базисные состояния
Посмотрим, как выглядят состояния кубитов со точно определенными значениями:
\begin{align*}
\ket{0} = \begin{bmatrix}1 + 0j \\ 0 + 0j\end{bmatrix} \text{\qquad} \ket{1} = \begin{bmatrix}0 + 0j \\ 1 + 0j\end{bmatrix}
\end{align*}

Что мы можем сказать об этих состояниях? Как минимум следующее:
- Они ортогональны ($\ket{0} \perp \ket{1}$)
- Они имеют единичную норму
- Они образуют базис

Что это значит для нас? А то, что любое состояние $\ket{\Psi}$ мы можем записать как линейную комбинацию векторов $\ket{0}$ и $\ket{1}$, причем коэффициенты в этой комбинации будут как раз наши $c_1, c_2$:

#+begin_src python
basis_0 = np.array([1 + 0j, 0 + 0j]).reshape((2, 1))
basis_1 = np.array([0 + 0j, 1 + 0j]).reshape((2, 1))

c1 = c2 = 1 / np.sqrt(2)

np.allclose(qubit, c1 * basis_0 + c2 * basis_1)
# True
#+end_src

*** Амплитуды вероятностей
Квантовая механика устроена таким интересным образом, что если мы будем измерять *значение* кубита, то вероятность каждого из вариантов будет пропорциональная соответствующему коэффициенту в разложении *состояния*. Но так как амплитуды у нас это в общем случае комплексные числа, а вероятности должны быть строго действительные, мы должны домножить амплитуды на комплексно сопряженные значения. В случае наших значений $c_1 = c_2 = \frac{1}{\sqrt{2}}$ мы получаем:
#+begin_src python
p0 = np.conj(c1) * c1
p1 = np.conj(c2) * c2

np.allclose(p0, p1)
# True

np.allclose(p0 + p1, 1.0)
# True
#+end_src

Тут мы сразу видим еще одну важную вещь -- сумма вероятностей всех состояний должна быть равна 100%. Это сразу приводит нас к тому, что состояния это не любые комплексные вектора, а комплексные вектора с единичной нормой:

#+begin_src python
np.allclose(np.conj(qubit).T @ qubit, 1.0)
# True
#+end_src

Мы будем очень часто пользоваться транспонирование и взятием комплексно сопряженного от векторов и в квантовой механике это имеет специальное обозначение $\bra{\Psi} = \Psi^{T\dagger}$ (бра -- вектор-строка). Тогда наше правило нормировки из NumPy кода может быть записано в нотации Дирака так:
\begin{align*}
\bra{\Psi}\ket{\Psi} = 1
\end{align*}

* Сфера Блоха
Надо понимать, что описанный нами выше базис $\ket{0}, \ket{1}$ не является единственно возможным базисом. Наши вектора $\ket{0}, \ket{1}$ это лишь самый часто применимый базис, который называют $\mathbf{Z}$ базисом. Но есть и другие варианты.


** Возможные базисы
*** Z-базис
Уже описанные нами $\ket{0}$ и $\ket{1}$.

*** X-базис
Базисные состояния $\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}$ и $\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}$:
#+begin_src python
plus = (basis_0 + basis_1) / np.sqrt(2)
minus = (basis_0 - basis_1) / np.sqrt(2)
#+end_src

*** Y-базис
Базисные состояния $\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}$ и $\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}$:
#+begin_src python
R = (basis_0 + 1j * basis_1) / np.sqrt(2)
L = (basis_0 - 1j * basis_1) / np.sqrt(2)
#+end_src

Легко можно убедиться, что все для каждого из этих базисов вектора ортогональны:
#+begin_src python
np.allclose(np.conj(basis_0).T @ basis_1, 0)
# True
np.allclose(np.conj(plus).T @ minus, 0)
# True
np.allclose(np.conj(R).T @ L, 0)
# True
#+end_src

Заметьте, что в наших векторных пространствах скалярное произведение это $ab = \bra{a}\ket{b}$! Именно поэтому мы должны делать транспонирование и комплексное сопряжение первого вектора в паре.

** Сфера Блоха
Обозначения $\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}$ выбраны не случайно -- они имеют геометрический смысл.

#+begin_center
#+caption: Сфера Блоха
#+attr_latex: :width 0.35\textwidth
[[./images/Blochcolor-alt.png]]
#+end_center

Принято считать, что ось $\mathbf{Z}$ это основная ось, так как физически, квантовые компьютеры измеряют именно по этой оси. Ось $\mathbf{X}$ она, если можно так выразиться, смотрит на нас и поэтому обозначается $\ket{+}$ и $\ket{-}$. А ось $\mathbf{Y}$ направлена как бы вдоль и поэтому базис обозначают как "право" ($\ket{R}$) и "лево" ($\ket{L}$).

Вектор состояния кубита также называют волновой функцией и этот вектор может идти в любую точку сферы Блоха. Так как сама сфера имеет единичный радиус, это гарантирует нам, что для всех состояний сумму квадратов амплитуд будет равна единице.

* А что можно делать с таким кубитом?
** Линейные операторы
Любое наше действие, которое мы совершаем с кубитом в состоянии $\ket{\Psi}$ должно переводить его в другое состояние $\ket{\Phi}$. Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица! Ну или, другими словами, линейный оператор. Мы будем обозначать их $\hat{U}$.

** Обратимость
Наша природа устроена таким образом, что почти все действия, которые мы совершаем с кубитом, должны быть обратимыми. То есть для каждого действия и операции (кроме измерений, но об этом чуть дальше), например $\hat{U}$, должно быть такое противодействие $\hat{U^\dagger}$, что оно вернет кубит в первоначальное состояние:
\begin{align*}
\hat{U}^\dagger = \hat{U}^T
\end{align*}

Тут $\dagger$ обозначает взятие комплексно сопряженного. А такие операторы называются самосопряженными.

** Унитарность
Как мы говорили, норма волновой функции должна быть нормирована на единицу, а значит любой оператор, который переводит одно состояние в другое $\hat{U}\ket{\Psi} = \ket{\Phi}$ должен сохранять нормировку, то есть должен быть *унитарным*. Более того, это свойство приводит к тому, что матрица сохраняет скалярное произведение:

\begin{align*}
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\end{align*}

Другими словами, унитарный оператор удовлетворяет условию $\hat{U}^\dagger \hat{U} = \hat{I}$

** Пример оператора
Большое число операторов мы будем разбирать в дальнейших лекция, так как именно операторы (или квантовые *гейты*) являются основой квантовых вычислений. А пока мы посмотрим один просто пример -- оператор Адамара (Hadamard gate) -- оператор, который переводит $\ket{0} \to \ket{+}$.

***   Гейт Адамара
Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита это вектор размерности два, а значит оператор, который переводит вектор размерности два в другой вектор размерности два это матрица $2\times 2$. Запишем оператор Адамара в матричном виде, а потом убедимся, что он эрмитов, унитарный, а еще, что он действительно переводит состояние $\ket{0} \to \ket{+}$.

\begin{align*}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\end{align*}

**** Реализация в Python
#+begin_src python
h = 1 / np.sqrt(2) * np.array([
    [1 + 0j, 1 + 0j],
    [1 + 0j, 0j - 1]
])
#+end_src

**** Самосопряженность
#+begin_src python
np.allclose(np.conj(h), h.T)
# True
#+end_src

**** Унитарность
#+begin_src python
np.allclose(np.conj(h) @ h, np.eye(2))
# True
#+end_src

**** Правильное действие
#+begin_src python
np.allclose(h @ basis_0, plus)
# True
#+end_src

* Измерения
Измерения в квантовых вычислениях стоят отдельно именно потому, что они "открывают" коробку с котом Шрёдингера -- мы точно узнаем, жив он, или мертв. Вся *суперпозиция* его состояния исчезает.

#+begin_export html
<details>
<summary>Немного о парадоксе измерений</summary>
Это интересный факт -- исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг "ломаются" и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения мы как бы "расщепляем" нашу вселенную на две ниточки -- в одной кот остается жив, а в другой остается мертв.

К сожалению, любые такие теории все равно остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Это скорее вопрос того, как каждый из нас понимает этот процесс, так как математически все такие теории в итоге дают один и тот же результат, который мы можем наблюдать и измерять.
</details>
#+end_export


#+begin_export latex


\textit{Это интересный факт -- исчезновение суперпозиции многим кажется парадоксом, именно поэтому и появляются разные интерпретации квантовой механики, например, многомировая интерпретация Эверетта. Действительно, это кажется немного странным, что полностью обратимая квантовая механика и непрерывная динамика волновых функций вдруг "ломаются" и мы получаем такой коллапс, который еще называют редукцией фон Неймана. Доктору Эверетт тоже это не нравилось и он предложил другую интерпретацию этого процесса. Согласно его теории, когда мы производим измерения мы как бы "расщепляем" нашу вселенную на две ниточки -- в одной кот остается жив, а в другой остается мертв.}

\textit{К сожалению, любые такие теории все равно остаются на уровне спекуляций, так как почти невозможно придумать эксперимент, который бы подтверждал или опровергал такую гипотезу. Это скорее вопрос того, как каждый из нас понимает этот процесс, так как математически все такие теории в итоге дают один и тот же результат, который мы можем наблюдать и измерять.}


#+end_export


Как мы уже говорили, у кубита может быть несколько разных базисов: $\ket{0}, \ket{1}$, $\ket{+}, \ket{-}$, $\ket{R}, \ket{L}$. *Значение* кубита в каждом из этих базисов может быть измерено. Но что такое измерение? Как это записать математически?

** Операторы Паули
На самом деле, любая наблюдаемая величина соответствует какому-то оператору. Например, измерения в разных базисах \mathbf{X}, \mathbf{Y}, \mathbf{Z} соответствуют операторам Паули:

\begin{align*}
\hat{\sigma^x} = \begin{bmatrix}0 & 1\\1 & 0\end{bmatrix}\qquad\hat{\sigma^y} = \begin{bmatrix}0 & -i\\i & 0\end{bmatrix}\qquad\hat{\sigma^z} = \begin{bmatrix}1 & 0\\0 & -1\end{bmatrix}
\end{align*}

#+begin_src python
pauli_x = np.array([[0 + 0j, 1 + 0j], [1 + 0j, 0 + 0j]])
pauli_y = np.array([[0 + 0j, 0 - 1j], [0 + 1j, 0 + 0j]])
pauli_z = np.array([[1 + 0j, 0 + 0j], [0 + 0j, 0j - 1]])
#+end_src

Эти операторы являются очень важными -- рекомендуется знать их наизусть, так как они встречаются в каждой 2-й статье по квантовым вычислениям, а также постоянно фигурируют в документации всех основных библиотек для квантового машинного обучения!

** Собственные значения
Хорошо, мы поняли, что есть какая-то связь между нашими измерениями и операторами. Но какая именно? Что значит, например, что измерения по оси $\mathbf{Z}$ соответствуют оператору $\hat{\sigma^Z}$?

И тут мы приходим к собственным значениям операторов. Оказывается (так устроен наш мир), что *измеряя* какую-то величину в квантовой механике мы всегда будем получать одно из собственных значений соответствующего оператора, а состояние будет коллапсировать в соответствующий собственный вектор этого оператора. Другими словами, *измеряя* кота Шрёдингера мы будем получать значения жив или мёртв, а состояние кота будет переходить в состояние, соответствующее одному из этих значений. А еще *измерение* не является обратимой операцией -- однажды открыв коробку с котом и увидев, что он жив или мертв, мы уже не сможем закрыть ее обратно и вернуть кота в суперпозицию.

Важно понимать, что это не просто что-то из квантовой физики -- понимание этих вещей нам очень пригодится потом, когда мы будем говорить о решении практических комбинаторных задач, таких, например, как задача о выделении сообществ в графе!

*** Собственные вектора $\hat{\sigma^Z}$
Вернемся к нашему оператору $\hat{\sigma^Z}$. Легко убедиться, что его собственные значения равны 1 и -1, а собственные соответствующие им собственные вектора это $\begin{bmatrix}1 \\ 0\end{bmatrix}$ и $\begin{bmatrix}0 \\ 1\end{bmatrix}$:
#+begin_src python
np.linalg.eig(pauli_z)
# (array([ 1.+0.j, -1.+0.j]),
# array([[1.+0.j, 0.+0.j],
#        [0.+0.j, 1.+0.j]]))
#+end_src

Таким образом, измерение по оси $\mathbf{Z}$ всегда будет давать нам одно из этих двух значений и переводить состояние кубита в соответствующий собственный вектор.

** Формальная запись
Формально мы можем записать это для любого эрмитова оператора $\hat{U}$, что собственные состояния этого оператора являются его собственными векторами, а собственные значения в этом случае являются наблюдаемыми значениями:
\begin{align*}
\hat{U}\ket{\Psi} = u\ket{\Psi}
\end{align*}

** Другие операторы Паули
Убедимся, что у остальных операторов собственные значения такие же:


#+begin_src python
np.linalg.eig(pauli_x)
# (array([ 1.+0.j, -1.+0.j]),
# array([[ 0.70710678-0.j,  0.70710678+0.j],
#        [ 0.70710678+0.j, -0.70710678+0.j]]))
#+end_src

#+begin_src python
np.linalg.eig(pauli_y)
# (array([ 1.+0.j, -1.+0.j]),
# array([[-0.        -0.70710678j,  0.70710678+0.j        ],
#        [ 0.70710678+0.j        ,  0.        -0.70710678j]]))
#+end_src

#+begin_export html
<details>
<summary>Принцип неопределенности Гейзенберга</summary>
Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда мы не можем одновременно точно измерить два разных оператора, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется принципом неопределенности.
</details>
#+end_export

#+begin_export latex


\textit{
Можно заметить, что у всех операторов Паули нет ни одного общего собственного вектора. Таким образом, мы приходим к ситуации, когда мы не можем одновременно точно измерить два разных оператора, так как наше измерение должно переводить состояние в соответствующий собственный вектор. В квантовой механике это называется принципом неопределенности.}


#+end_export

** Ожидаемое значение при измерении
Мы не будем писать полный симулятор кубитов, который включает измерения -- это требует введения сложного случайного процесса. Но мы можем легко ответить на другой вопрос. А именно, мы можем сказать, а какое будет *ожидаемое* значение оператора $\hat{U}$ для состояния $\Psi$? Ну или, другими словами, какое будет математическое ожидание большого числа измерений. Это можно записать следующим образом:
\begin{align*}
\mathbf{E}(\hat{U}) = \bra{\Psi}\hat{U}\ket{\Psi}
\end{align*}

Например, оператор $\hat{\sigma^z}$ полностью не определен в состоянии $\ket{+}$, то есть мы будем равновероятно получать значения -1 и 1, а математическое ожидание будет равно нулю:
#+begin_src python
plus.conj().T @ pauli_z @ plus
# array([[0.+0.j]])
#+end_src

С другой стороны, измеряя состояние $\ket{+}$ в X-базисе мы всегда будем получать 1:
#+begin_src python
plus.conj().T @ pauli_x @ plus
# array([[1.+0.j]])
#+end_src

* Что мы узнали?
- Состояние и значение для кубита не одно и то же
- Состояния -- вектора в Гильбертовом пространстве
- Квантовые операторы унитарные и самосопряженные
- Измеряемые значения -- собственные значения операторов
- Измерение ломает суперпозицию
