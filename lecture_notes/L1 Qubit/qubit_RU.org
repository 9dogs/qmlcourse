#+TITLE: Кубит
#+AUTHOR: Семен Синченко

* Описание лекции
Из этой лекции мы узнаем:
- Что такое кубит
- В чем разница между значением и состоянием
- Что такое сфера Блоха
- Какие можно делать операции над кубитами
- Что такое измерение

* Что такое кубит

Как мы знаем, классический компьютер оперирует двоичными числами (0 и 1). Минимальный объем информации для классического компьютера называется бит. Квантовый компьютер оперирует квантовыми битами, или кубитами. Если мы будем считывать кубит, то он также как и классический бит, будет иметь лишь два возможных значения (0 и 1). Так в чем же разница с обычным битом? В чем особенности квантовых компьютеров, которые и дают им преимущества над классическими компьютерами?

Вся суть на самом деле в том, что для квантомеханичеких систем (и кубитов в частности) их *состояния* и *значения* это не одно и то же!

* Состояние vs значение

** Состояние классического бита
Обычно мы не отличаем состояние классического бита от его значения и считаем, что если бит имеет значение $\mathbf{1}$, то и состояние его описывается числом $\mathbf{1}$.

** Кот Шрёдингера
Давайте вспомним известный мысленный эксперимента Шрёдингера - кот, который одновременно и жив и мертв. Понятно, что *значение* кота точно одно - он либо жив, либо мертв. Но *состояние* его более сложное - он находится в *суперпозиции* состояний жив и мертв одновременно!

** Состояние кубита
Состояние кубита, если можно так сказать, аналогично коту Шрёдингера: оно отличается от значения кубита и описывается вектором из двух комплексных чисел. Мы будем обозначать состояния (или вектора) символом $\ket{\Psi}$ (кет -- вектор-столбец) - это широко принятая в квантовой механике и квантовых вычислениях нотация Дирака:
\begin{align*}
\ket{\Psi} = \begin{bmatrix}
c_1 \\
c_2
\end{bmatrix}
\end{align*}

Что именно значат числа $c_1$ и $c_2$ мы поговорим чуть далее, а пока запишем наш кубит $\ket{\Psi}$ в коде Python. Возьмем, для начала, $c_1 = c_2 = \frac{1}{\sqrt{2}}$.

#+begin_src python
import numpy as np
qubit = np.array([1 / np.sqrt(2) + 0j, 1 / np.sqrt(2) + 0j])
#+end_src

** Связь состояния и значения кубита
А теперь разберем подробнее, что же такое наш вектор $\ket{\Psi}$ и что же значат цифры $c_1, c_2$. Для начала посмотрим на то, а какие состояния имеет кубит, для которого мы точно знаем значение. То есть посмотрим на кота Шрёдингера, но который точно жив или точно мертв.

*** Базисные состояния
Посмотрим, как выглядят состояния кубитов со точно определенными значениями:
\begin{align*}
\ket{0} = \begin{bmatrix}1 + 0j \\ 0 + 0j\end{bmatrix} \text{\qquad} \ket{1} = \begin{bmatrix}0 + 0j \\ 1 + 0j\end{bmatrix}
\end{align*}

Что мы можем сказать об этих состояниях? Как минимум следующее:
- Они ортогональны ($\ket{0} \perp \ket{1}$)
- Они имеют единичную норму
- Они образуют базис

Что это значит для нас? А то, что любое состояние $\ket{\Psi}$ мы можем записать как линейную комбинацию векторов $\ket{0}$ и $\ket{1}$, причем коэффициенты в этой комбинации будут как раз наши $c_1, c_2$:

#+begin_src python
basis_0 = np.array([1 + 0j, 0 + 0j])
basis_1 = np.array([0 + 0j, 1 + 0j])

c1 = c2 = 1 / np.sqrt(2)

np.allclose(
    qubit,
    c1 * basis_0 + c2 * basis_1
)
# True
#+end_src

*** Амплитуды вероятностей
Квантовая механика устроена таким интересным образом, что если мы будем измерять *значение* кубита, то вероятность каждого из вариантов будет пропорциональная соответствующему коэффициенту в разложении *состояния*. Но так как амплитуды у нас это в общем случае комплексные числа, а вероятности должны быть строго действительные, мы должны домножить амплитуды на комплексно сопряженные значения. В случае наших значений $c_1 = c_2 = \frac{1}{\sqrt{2}}$ мы получаем:
#+begin_src python
p0 = np.conj(c1) * c1
p1 = np.conj(c2) * c2

np.allclose(p0, p1)
# True

np.allclose(p0 + p1, 1.0)
# True
#+end_src

Тут мы сразу видим еще одну важную вещь -- сумма вероятностей всех состояний должна быть равна 100%. Это сразу приводит нас к тому, что состояния это не любые комплексные вектора, а комплексные вектора с единичной нормой:

#+begin_src python
np.allclose(np.conj(qubit) @ qubit, 1.0)
# True
#+end_src

Мы будем очень часто пользоваться транспонирование и взятием комплексно сопряженного от векторов и в квантовой механике это имеет специальное обозначение $\bra{\Psi} = \Psi^{T\dagger}$ (бра -- вектор-строка). Тогда наше правило нормировки из NumPy кода может быть записано в нотации Дирака так:
\begin{align*}
\bra{\Psi}\ket{\Psi} = 1
\end{align*}

* Сфера Блоха
Надо понимать, что описанный нами выше базис $\ket{0}, \ket{1}$ не является единственно возможным базисом. Наши вектора $\ket{0}, \ket{1}$ это лишь самый часто применимый базис, который называют $\mathbf{Z}$ базисом. Но есть и другие варианты.


** Возможные базисы
*** $\mathbf{Z}$-базис
Уже описанные нами $\ket{0}$ и $\ket{1}$.

*** $\mathbf{X}$-базис
Базисные состояния $\ket{+} = \frac{\ket{0} + \ket{1}}{\sqrt{2}}$ и $\ket{-} = \frac{\ket{0} - \ket{1}}{\sqrt{2}}$:
#+begin_src python
plus = (basis_0 + basis_1) / np.sqrt(2)
minus = (basis_0 - basis_1) / np.sqrt(2)
#+end_src

*** $\mathbf{Y}$-базис
Базисные состояния $\ket{R} = \frac{\ket{0} + i\ket{1}}{\sqrt{2}}$ и $\ket{L} = \frac{\ket{0} - i\ket{1}}{\sqrt{2}}$:
#+begin_src python
R = (basis_0 + 1j * basis_1) / np.sqrt(2)
L = (basis_0 - 1j * basis_1) / np.sqrt(2)
#+end_src

Легко можно убедиться, что все для каждого из этих базисов вектора ортогональны:
#+begin_src python
np.allclose(np.conj(basis_0) @ basis_1, 0)
# True
np.allclose(np.conj(plus) @ minus, 0)
# True
np.allclose(np.conj(R) @ L, 0)
# True
#+end_src

Заметьте, что в наших векторных пространствах скалярное произведение это $ab = \bra{a}\ket{b}$! Именно поэтому мы должны делать транспонирование и комплексное сопряжение первого вектора в паре.

** Сфера Блоха
Обозначения $\ket{0}, \ket{1}, \ket{+}, \ket{-}, \ket{R}, \ket{L}$ выбраны не случайно - они имеют геометрический смысл.
#+begin_center
#+caption: Сфера Блоха
#+name: bloch_sphere
[[https://upload.wikimedia.org/wikipedia/commons/f/f5/Blochcolor-alt.png]]
#+end_center

Принято считать, что ось $\mathbf{Z}$ это основная ось, так как физически, квантовые компьютеры измеряют именно по этой оси. Ось $\mathbf{X}$ она, если можно так выразиться, смотрит на нас и поэтому обозначается $\ket{+}$ и $\ket{-}$. А ось $\mathbf{Y}$ направлена как бы вдоль и поэтому базис обозначают как "право" ($\ket{R}$) и "лево" ($\ket{L}$).

Вектор состояния кубита также называют волновой функцией и этот вектор может идти в любую точку сферы Блоха. Так как сама сфера имеет единичный радиус, это гарантирует нам, что для всех состояний сумму квадратов амплитуд будет равна единице.

* А что можно делать с таким кубитом?
** Линейные операторы
Любое наше действие, которое мы совершаем с кубитом в состоянии $\ket{\Psi}$ должно переводить его в другое состояние $\ket{\Phi}$. Что переводит один вектор в другой вектор в том же пространстве? Правильно, матрица! Ну или, другими словами, линейный оператор. Мы будем обозначать их $\hat{U}$.

** Обратимость
Наша природа устроена таким образом, что почти все действия, которые мы совершаем с кубитом, должны быть обратимыми. То есть для каждого действия и операции (кроме измерений, но об этом чуть дальше), например $\hat{U}$, должно быть такое противодействие $\hat{U^\dagger}$, что оно вернет кубит в первоначальное состояние:
\begin{align*}
\hat{U}^\dagger = \hat{U}^T
\end{align*}

Тут $\dagger$ обозначает взятие комплексно сопряженного. А такие операторы называются самосопряженными.

** Унитарность
Как мы говорили, норма волновой функции должна быть нормирована на единицу, а значит любой оператор, который переводит одно состояние в другое $\hat{U}\ket{\Psi} = \ket{\Phi}$ должен сохранять нормировку, то есть должен быть *унитарным*. Более того, это свойство приводит к тому, что матрица сохраняет скалярное произведение:

\begin{align*}
\bra{\Psi}\hat{U}^\dagger\hat{U}\ket{\Psi} = \bra{\Psi}\ket{\Psi}
\end{align*}

Другими словами, унитарный оператор удовлетворяет условию $\hat{U}^\dagger \hat{U} = \hat{I}$

** Пример оператора
Большое число операторов мы будем разбирать в дальнейших лекция, так как именно операторы (или квантовые *гейты*) являются основой квантовых вычислений. А пока мы посмотрим один просто пример - оператор Адамара (Hadamard gate) - оператор, который переводит $\ket{0} \to \ket{+}$.

***   Гейт Адамара
Начнем с того, что пока у нас лишь один кубит. Состояние одного кубита это вектор размерности два, а значит оператор, который переводит вектор размерности два в другой вектор размерности два это матрица $2\times 2$. Запишем оператор Адамара в матричном виде, а потом убедимся, что он эрмитов, унитарный, а еще, что он действительно переводит состояние $\ket{0} \to \ket{+}$.

\begin{align*}
\hat{H} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 & 1 \\
1 & -1 \\
\end{bmatrix}
\end{align*}

**** Реализация в Python
#+begin_src python
h = 1 / np.sqrt(2) * np.array([
    [1 + 0j, 1 + 0j],
    [1 + 0j, 0j - 1]
])
#+end_src

**** Самосопряженность
#+begin_src python
np.allclose(np.conj(h), h.T)
# True
#+end_src

**** Унитарность
#+begin_src python
np.allclose(np.conj(h) @ h, np.eye(2))
# True
#+end_src

**** Правильное действие
#+begin_src python
np.allclose(h @ basis_0, plus)
# True
#+end_src
